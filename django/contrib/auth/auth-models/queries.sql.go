// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package models

import (
	"context"
	"strings"
)

const addPermissionToGroup = `-- name: AddPermissionToGroup :exec
INSERT INTO group_permissions (group_id, permission_id)
VALUES (?, ?)
`

func (q *Queries) AddPermissionToGroup(ctx context.Context, groupID uint64, permissionID uint64) error {
	_, err := q.db.ExecContext(ctx, addPermissionToGroup, groupID, permissionID)
	return err
}

const addUserToGroup = `-- name: AddUserToGroup :exec
INSERT INTO user_groups (user_id, group_id)
VALUES (?, ?)
`

func (q *Queries) AddUserToGroup(ctx context.Context, userID uint64, groupID uint64) error {
	_, err := q.db.ExecContext(ctx, addUserToGroup, userID, groupID)
	return err
}

const addUserToGroups = `-- name: AddUserToGroups :exec
INSERT INTO user_groups (user_id, group_id)
SELECT ? AS user_id, group_id
FROM (SELECT id, name, description FROM ` + "`" + `groups` + "`" + ` WHERE id IN (/*SLICE:group_ids*/?)) AS t
`

func (q *Queries) AddUserToGroups(ctx context.Context, userID uint64, groupIds []uint64) error {
	query := addUserToGroups
	var queryParams []interface{}
	queryParams = append(queryParams, userID)
	if len(groupIds) > 0 {
		for _, v := range groupIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:group_ids*/?", strings.Repeat(",?", len(groupIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:group_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const checkUserHasPermissions = `-- name: CheckUserHasPermissions :one
SELECT EXISTS (
    SELECT 1
    FROM users u
    JOIN user_groups ug ON u.id = ug.user_id
    JOIN ` + "`" + `groups` + "`" + ` g ON ug.group_id = g.id
    JOIN group_permissions gp ON g.id = gp.group_id
    JOIN permissions p ON gp.permission_id = p.id
    WHERE u.id = ? AND p.name IN (/*SLICE:permissionnames*/?)
) as has_permissions
`

func (q *Queries) CheckUserHasPermissions(ctx context.Context, iD uint64, permissionnames []string) (bool, error) {
	query := checkUserHasPermissions
	var queryParams []interface{}
	queryParams = append(queryParams, iD)
	if len(permissionnames) > 0 {
		for _, v := range permissionnames {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:permissionnames*/?", strings.Repeat(",?", len(permissionnames))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:permissionnames*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var has_permissions bool
	err := row.Scan(&has_permissions)
	return has_permissions, err
}

const createGroup = `-- name: CreateGroup :exec
INSERT INTO ` + "`" + `groups` + "`" + ` (name, description)
VALUES (?, ?)
`

func (q *Queries) CreateGroup(ctx context.Context, name string, description string) error {
	_, err := q.db.ExecContext(ctx, createGroup, name, description)
	return err
}

const createPermission = `-- name: CreatePermission :exec
INSERT INTO permissions (name, description)
VALUES (?, ?)
`

func (q *Queries) CreatePermission(ctx context.Context, name string, description string) error {
	_, err := q.db.ExecContext(ctx, createPermission, name, description)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (email, username, password, first_name, last_name, is_administrator, is_active)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	Email           string `json:"email"`
	Username        string `json:"username"`
	Password        string `json:"password"`
	FirstName       string `json:"first_name"`
	LastName        string `json:"last_name"`
	IsAdministrator bool   `json:"is_administrator"`
	IsActive        bool   `json:"is_active"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.FirstName,
		arg.LastName,
		arg.IsAdministrator,
		arg.IsActive,
	)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM ` + "`" + `groups` + "`" + ` WHERE id = ?
`

func (q *Queries) DeleteGroup(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions WHERE id = ?
`

func (q *Queries) DeletePermission(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, deletePermission, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteUserGroups = `-- name: DeleteUserGroups :exec
DELETE FROM user_groups
WHERE user_id = ?
`

func (q *Queries) DeleteUserGroups(ctx context.Context, userID uint64) error {
	_, err := q.db.ExecContext(ctx, deleteUserGroups, userID)
	return err
}

const getAllGroups = `-- name: GetAllGroups :many
SELECT id, name, description FROM ` + "`" + `groups` + "`" + `
`

func (q *Queries) GetAllGroups(ctx context.Context) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getAllGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPermissions = `-- name: GetAllPermissions :many
SELECT id, name, description FROM permissions
`

func (q *Queries) GetAllPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getAllPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, created_at, updated_at, email, username, password, first_name, last_name, is_administrator, is_active FROM users
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.FirstName,
			&i.LastName,
			&i.IsAdministrator,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT id, name, description FROM ` + "`" + `groups` + "`" + ` WHERE id = ?
`

func (q *Queries) GetGroupByID(ctx context.Context, id uint64) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupByID, id)
	var i Group
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getGroupsByUserID = `-- name: GetGroupsByUserID :many
SELECT g.id, g.name, g.description
FROM ` + "`" + `groups` + "`" + ` g
JOIN user_groups ug ON g.id = ug.group_id
WHERE ug.user_id = ?
`

func (q *Queries) GetGroupsByUserID(ctx context.Context, userID uint64) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsWithPagination = `-- name: GetGroupsWithPagination :many
SELECT id, name, description FROM ` + "`" + `groups` + "`" + `
ORDER BY id
LIMIT ? OFFSET ?
`

func (q *Queries) GetGroupsWithPagination(ctx context.Context, limit int32, offset int32) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsWithPagination, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionByID = `-- name: GetPermissionByID :one
SELECT id, name, description FROM permissions WHERE id = ?
`

func (q *Queries) GetPermissionByID(ctx context.Context, id uint64) (Permission, error) {
	row := q.db.QueryRowContext(ctx, getPermissionByID, id)
	var i Permission
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getPermissionByName = `-- name: GetPermissionByName :one
SELECT p.id, p.name, p.description
FROM permissions p
WHERE p.name = ?
`

func (q *Queries) GetPermissionByName(ctx context.Context, name string) (Permission, error) {
	row := q.db.QueryRowContext(ctx, getPermissionByName, name)
	var i Permission
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getPermissionsByUserID = `-- name: GetPermissionsByUserID :many
SELECT DISTINCT p.id, p.name, p.description
FROM permissions p
JOIN group_permissions gp ON p.id = gp.permission_id
JOIN user_groups ug ON gp.group_id = ug.group_id
WHERE ug.user_id = ?
`

func (q *Queries) GetPermissionsByUserID(ctx context.Context, userID uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByUserIDAndPermissionNames = `-- name: GetPermissionsByUserIDAndPermissionNames :many
SELECT DISTINCT p.id, p.name, p.description
FROM permissions p
JOIN group_permissions gp ON p.id = gp.permission_id
JOIN user_groups ug ON gp.group_id = ug.group_id
WHERE ug.user_id = ? AND p.name IN (/*SLICE:permissionnames*/?)
`

func (q *Queries) GetPermissionsByUserIDAndPermissionNames(ctx context.Context, userID uint64, permissionnames []string) ([]Permission, error) {
	query := getPermissionsByUserIDAndPermissionNames
	var queryParams []interface{}
	queryParams = append(queryParams, userID)
	if len(permissionnames) > 0 {
		for _, v := range permissionnames {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:permissionnames*/?", strings.Repeat(",?", len(permissionnames))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:permissionnames*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsWithPagination = `-- name: GetPermissionsWithPagination :many
SELECT id, name, description FROM permissions
ORDER BY id
LIMIT ? OFFSET ?
`

func (q *Queries) GetPermissionsWithPagination(ctx context.Context, limit int32, offset int32) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsWithPagination, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :many
SELECT
    u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active,
    g.id AS group_id, g.name AS group_name, g.description AS group_description,
    p.id AS permission_id, p.name AS permission_name, p.description AS permission_description
FROM
    users u
JOIN
    user_groups ug ON u.id = ug.user_id
JOIN
    ` + "`" + `groups` + "`" + ` g ON ug.group_id = g.id
JOIN
    group_permissions gp ON g.id = gp.group_id
JOIN
    permissions p ON gp.permission_id = p.id
WHERE
    u.email = ?
ORDER BY
    u.id, g.name, p.name
`

type GetUserByEmailRow struct {
	User                  User   `json:"user"`
	GroupID               uint64 `json:"group_id"`
	GroupName             string `json:"group_name"`
	GroupDescription      string `json:"group_description"`
	PermissionID          uint64 `json:"permission_id"`
	PermissionName        string `json:"permission_name"`
	PermissionDescription string `json:"permission_description"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) ([]GetUserByEmailRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserByEmailRow
	for rows.Next() {
		var i GetUserByEmailRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Email,
			&i.User.Username,
			&i.User.Password,
			&i.User.FirstName,
			&i.User.LastName,
			&i.User.IsAdministrator,
			&i.User.IsActive,
			&i.GroupID,
			&i.GroupName,
			&i.GroupDescription,
			&i.PermissionID,
			&i.PermissionName,
			&i.PermissionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :many
SELECT
    u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active,
    g.id AS group_id, g.name AS group_name, g.description AS group_description,
    p.id AS permission_id, p.name AS permission_name, p.description AS permission_description
FROM
    users u
JOIN
    user_groups ug ON u.id = ug.user_id
JOIN
    ` + "`" + `groups` + "`" + ` g ON ug.group_id = g.id
JOIN
    group_permissions gp ON g.id = gp.group_id
JOIN
    permissions p ON gp.permission_id = p.id
WHERE
    u.id = ?
ORDER BY
    u.id, g.name, p.name
`

type GetUserByIdRow struct {
	User                  User   `json:"user"`
	GroupID               uint64 `json:"group_id"`
	GroupName             string `json:"group_name"`
	GroupDescription      string `json:"group_description"`
	PermissionID          uint64 `json:"permission_id"`
	PermissionName        string `json:"permission_name"`
	PermissionDescription string `json:"permission_description"`
}

func (q *Queries) GetUserById(ctx context.Context, id uint64) ([]GetUserByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserByIdRow
	for rows.Next() {
		var i GetUserByIdRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Email,
			&i.User.Username,
			&i.User.Password,
			&i.User.FirstName,
			&i.User.LastName,
			&i.User.IsAdministrator,
			&i.User.IsActive,
			&i.GroupID,
			&i.GroupName,
			&i.GroupDescription,
			&i.PermissionID,
			&i.PermissionName,
			&i.PermissionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByName = `-- name: GetUserByName :many
SELECT
    u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active,
    g.id AS group_id, g.name AS group_name, g.description AS group_description,
    p.id AS permission_id, p.name AS permission_name, p.description AS permission_description
FROM
    users u
JOIN
    user_groups ug ON u.id = ug.user_id
JOIN
    ` + "`" + `groups` + "`" + ` g ON ug.group_id = g.id
JOIN
    group_permissions gp ON g.id = gp.group_id
JOIN
    permissions p ON gp.permission_id = p.id
WHERE
    u.username = ?
ORDER BY
    u.id
`

type GetUserByNameRow struct {
	User                  User   `json:"user"`
	GroupID               uint64 `json:"group_id"`
	GroupName             string `json:"group_name"`
	GroupDescription      string `json:"group_description"`
	PermissionID          uint64 `json:"permission_id"`
	PermissionName        string `json:"permission_name"`
	PermissionDescription string `json:"permission_description"`
}

func (q *Queries) GetUserByName(ctx context.Context, username string) ([]GetUserByNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserByName, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserByNameRow
	for rows.Next() {
		var i GetUserByNameRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Email,
			&i.User.Username,
			&i.User.Password,
			&i.User.FirstName,
			&i.User.LastName,
			&i.User.IsAdministrator,
			&i.User.IsActive,
			&i.GroupID,
			&i.GroupName,
			&i.GroupDescription,
			&i.PermissionID,
			&i.PermissionName,
			&i.PermissionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByPermissionID = `-- name: GetUsersByPermissionID :many
SELECT DISTINCT u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active
FROM users u
JOIN user_groups ug ON u.id = ug.user_id
JOIN group_permissions gp ON ug.group_id = gp.group_id
WHERE gp.permission_id = ?
`

func (q *Queries) GetUsersByPermissionID(ctx context.Context, permissionID uint64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByPermissionID, permissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.FirstName,
			&i.LastName,
			&i.IsAdministrator,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithPagination = `-- name: GetUsersWithPagination :many
SELECT id, created_at, updated_at, email, username, password, first_name, last_name, is_administrator, is_active FROM users
ORDER BY id
LIMIT ? OFFSET ?
`

func (q *Queries) GetUsersWithPagination(ctx context.Context, limit int32, offset int32) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithPagination, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.FirstName,
			&i.LastName,
			&i.IsAdministrator,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const groupsDoNotBelongTo = `-- name: GroupsDoNotBelongTo :many
SELECT g.id, g.name, g.description
FROM ` + "`" + `groups` + "`" + ` g
WHERE g.id NOT IN (
    SELECT ug.group_id
    FROM user_groups ug
    WHERE ug.user_id = ?
)
`

func (q *Queries) GroupsDoNotBelongTo(ctx context.Context, userID uint64) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, groupsDoNotBelongTo, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissionsInGroup = `-- name: ListPermissionsInGroup :many
SELECT p.id, p.name, p.description FROM permissions p JOIN group_permissions gp ON p.id = gp.permission_id WHERE gp.group_id = ?
`

func (q *Queries) ListPermissionsInGroup(ctx context.Context, groupID uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, listPermissionsInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersInGroup = `-- name: ListUsersInGroup :many
SELECT u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active FROM users u JOIN user_groups ug ON u.id = ug.user_id WHERE ug.group_id = ?
`

func (q *Queries) ListUsersInGroup(ctx context.Context, groupID uint64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsersInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.FirstName,
			&i.LastName,
			&i.IsAdministrator,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const permissionsNotInGroup = `-- name: PermissionsNotInGroup :many
SELECT p.id, p.name, p.description
FROM permissions p
WHERE p.id NOT IN (
    SELECT permission_id
    FROM group_permissions
    WHERE group_id = ?
)
`

func (q *Queries) PermissionsNotInGroup(ctx context.Context, groupID uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, permissionsNotInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const permissionsNotInUser = `-- name: PermissionsNotInUser :many
SELECT p.id, p.name, p.description
FROM permissions p
WHERE p.id NOT IN (
    SELECT gp.permission_id
    FROM user_groups ug
    JOIN group_permissions gp ON ug.group_id = gp.group_id
    WHERE ug.user_id = ?
)
`

func (q *Queries) PermissionsNotInUser(ctx context.Context, userID uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, permissionsNotInUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePermissionFromGroup = `-- name: RemovePermissionFromGroup :exec
DELETE FROM group_permissions WHERE group_id = ? AND permission_id = ?
`

func (q *Queries) RemovePermissionFromGroup(ctx context.Context, groupID uint64, permissionID uint64) error {
	_, err := q.db.ExecContext(ctx, removePermissionFromGroup, groupID, permissionID)
	return err
}

const removeUserFromGroup = `-- name: RemoveUserFromGroup :exec
DELETE FROM user_groups WHERE user_id = ? AND group_id = ?
`

func (q *Queries) RemoveUserFromGroup(ctx context.Context, userID uint64, groupID uint64) error {
	_, err := q.db.ExecContext(ctx, removeUserFromGroup, userID, groupID)
	return err
}

const updateGroup = `-- name: UpdateGroup :exec
UPDATE ` + "`" + `groups` + "`" + ` SET name = ?, description = ? WHERE id = ?
`

func (q *Queries) UpdateGroup(ctx context.Context, name string, description string, iD uint64) error {
	_, err := q.db.ExecContext(ctx, updateGroup, name, description, iD)
	return err
}

const updatePermission = `-- name: UpdatePermission :exec
UPDATE permissions SET name = ?, description = ? WHERE id = ?
`

func (q *Queries) UpdatePermission(ctx context.Context, name string, description string, iD uint64) error {
	_, err := q.db.ExecContext(ctx, updatePermission, name, description, iD)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET email = ?, username = ?, password = ?, first_name = ?, last_name = ?, is_administrator = ?, is_active = ? WHERE id = ?
`

type UpdateUserParams struct {
	Email           string `json:"email"`
	Username        string `json:"username"`
	Password        string `json:"password"`
	FirstName       string `json:"first_name"`
	LastName        string `json:"last_name"`
	IsAdministrator bool   `json:"is_administrator"`
	IsActive        bool   `json:"is_active"`
	ID              uint64 `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.FirstName,
		arg.LastName,
		arg.IsAdministrator,
		arg.IsActive,
		arg.ID,
	)
	return err
}
