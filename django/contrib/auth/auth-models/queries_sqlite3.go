// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sqlite3.sql

package models

import (
	"context"
	"strings"
)

var _ Querier = (*SQLiteQueries)(nil)

const sqlite_addPermissionToGroup = `-- name: AddPermissionToGroup :exec
INSERT INTO group_permissions (group_id, permission_id)
VALUES (?, ?)
`

func (q *SQLiteQueries) AddPermissionToGroup(ctx context.Context, groupID uint64, permissionID uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_addPermissionToGroup, groupID, permissionID)
	return err
}

const sqlite_addUserToGroup = `-- name: AddUserToGroup :exec
INSERT INTO user_groups (user_id, group_id)
VALUES (?, ?)
`

func (q *SQLiteQueries) AddUserToGroup(ctx context.Context, userID uint64, groupID uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_addUserToGroup, userID, groupID)
	return err
}

const sqlite_addUserToGroups = `-- name: AddUserToGroups :exec
INSERT INTO user_groups (user_id, group_id)
SELECT ? AS user_id, group_id
FROM (SELECT id, name, description FROM groups WHERE id IN (/*SLICE:group_ids*/?)) AS t
`

func (q *SQLiteQueries) AddUserToGroups(ctx context.Context, userID uint64, groupIds []uint64) error {
	query := sqlite_addUserToGroups
	var queryParams []interface{}
	queryParams = append(queryParams, userID)
	if len(groupIds) > 0 {
		for _, v := range groupIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:group_ids*/?", strings.Repeat(",?", len(groupIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:group_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const sqlite_checkUserHasPermissions = `-- name: CheckUserHasPermissions :one
SELECT EXISTS (
    SELECT 1
    FROM users u
    JOIN user_groups ug ON u.id = ug.user_id
    JOIN groups g ON ug.group_id = g.id
    JOIN group_permissions gp ON g.id = gp.group_id
    JOIN permissions p ON gp.permission_id = p.id
    WHERE u.id = ? AND p.name IN (/*SLICE:permissionnames*/?)
) as has_permissions
`

func (q *SQLiteQueries) CheckUserHasPermissions(ctx context.Context, iD uint64, permissionnames []string) (bool, error) {
	query := sqlite_checkUserHasPermissions
	var queryParams []interface{}
	queryParams = append(queryParams, iD)
	if len(permissionnames) > 0 {
		for _, v := range permissionnames {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:permissionnames*/?", strings.Repeat(",?", len(permissionnames))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:permissionnames*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var has_permissions uint64
	err := row.Scan(&has_permissions)
	return has_permissions > 0, err
}

const sqlite_createGroup = `-- name: CreateGroup :exec
INSERT INTO groups (name, description)
VALUES (?, ?)
`

func (q *SQLiteQueries) CreateGroup(ctx context.Context, name string, description string) error {
	_, err := q.db.ExecContext(ctx, sqlite_createGroup, name, description)
	return err
}

const sqlite_createPermission = `-- name: CreatePermission :exec
INSERT INTO permissions (name, description)
VALUES (?, ?)
`

func (q *SQLiteQueries) CreatePermission(ctx context.Context, name string, description string) error {
	_, err := q.db.ExecContext(ctx, sqlite_createPermission, name, description)
	return err
}

const sqlite_createUser = `-- name: CreateUser :exec
INSERT INTO users (email, username, password, first_name, last_name, is_administrator, is_active)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

func (q *SQLiteQueries) CreateUser(ctx context.Context, email string, username string, password string, firstName string, lastName string, isAdministrator bool, isActive bool) error {
	_, err := q.db.ExecContext(ctx, sqlite_createUser,
		email,
		username,
		password,
		firstName,
		lastName,
		isAdministrator,
		isActive,
	)
	return err
}

const sqlite_deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM groups WHERE id = ?
`

func (q *SQLiteQueries) DeleteGroup(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_deleteGroup, id)
	return err
}

const sqlite_deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions WHERE id = ?
`

func (q *SQLiteQueries) DeletePermission(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_deletePermission, id)
	return err
}

const sqlite_deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?
`

func (q *SQLiteQueries) DeleteUser(ctx context.Context, id uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_deleteUser, id)
	return err
}

const sqlite_deleteUserGroups = `-- name: DeleteUserGroups :exec
DELETE FROM user_groups
WHERE user_id = ?
`

func (q *SQLiteQueries) DeleteUserGroups(ctx context.Context, userID uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_deleteUserGroups, userID)
	return err
}

const sqlite_getAllGroups = `-- name: GetAllGroups :many
SELECT id, name, description FROM groups
`

func (q *SQLiteQueries) GetAllGroups(ctx context.Context) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getAllGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getAllPermissions = `-- name: GetAllPermissions :many
SELECT id, name, description FROM permissions
`

func (q *SQLiteQueries) GetAllPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getAllPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getAllUsers = `-- name: GetAllUsers :many
SELECT id, created_at, updated_at, email, username, password, first_name, last_name, is_administrator, is_active FROM users
`

func (q *SQLiteQueries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.FirstName,
			&i.LastName,
			&i.IsAdministrator,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getGroupByID = `-- name: GetGroupByID :one
SELECT id, name, description FROM groups WHERE id = ?
`

func (q *SQLiteQueries) GetGroupByID(ctx context.Context, id uint64) (Group, error) {
	row := q.db.QueryRowContext(ctx, sqlite_getGroupByID, id)
	var i Group
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const sqlite_getGroupsByUserID = `-- name: GetGroupsByUserID :many
SELECT g.id, g.name, g.description
FROM groups g
JOIN user_groups ug ON g.id = ug.group_id
WHERE ug.user_id = ?
`

func (q *SQLiteQueries) GetGroupsByUserID(ctx context.Context, userID uint64) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getGroupsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getGroupsWithPagination = `-- name: GetGroupsWithPagination :many
SELECT id, name, description FROM groups
ORDER BY id
LIMIT ? OFFSET ?
`

func (q *SQLiteQueries) GetGroupsWithPagination(ctx context.Context, limit uint64, offset uint64) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getGroupsWithPagination, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getPermissionByID = `-- name: GetPermissionByID :one
SELECT id, name, description FROM permissions WHERE id = ?
`

func (q *SQLiteQueries) GetPermissionByID(ctx context.Context, id uint64) (Permission, error) {
	row := q.db.QueryRowContext(ctx, sqlite_getPermissionByID, id)
	var i Permission
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const sqlite_getPermissionByName = `-- name: GetPermissionByName :one
SELECT p.id, p.name, p.description
FROM permissions p
WHERE p.name = ?
`

func (q *SQLiteQueries) GetPermissionByName(ctx context.Context, name string) (Permission, error) {
	row := q.db.QueryRowContext(ctx, sqlite_getPermissionByName, name)
	var i Permission
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const sqlite_getPermissionsByUserID = `-- name: GetPermissionsByUserID :many
SELECT DISTINCT p.id, p.name, p.description
FROM permissions p
JOIN group_permissions gp ON p.id = gp.permission_id
JOIN user_groups ug ON gp.group_id = ug.group_id
WHERE ug.user_id = ?
`

func (q *SQLiteQueries) GetPermissionsByUserID(ctx context.Context, userID uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getPermissionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getPermissionsByUserIDAndPermissionNames = `-- name: GetPermissionsByUserIDAndPermissionNames :many
SELECT DISTINCT p.id, p.name, p.description
FROM permissions p
JOIN group_permissions gp ON p.id = gp.permission_id
JOIN user_groups ug ON gp.group_id = ug.group_id
WHERE ug.user_id = ? AND p.name IN (/*SLICE:permissionnames*/?)
`

func (q *SQLiteQueries) GetPermissionsByUserIDAndPermissionNames(ctx context.Context, userID uint64, permissionnames []string) ([]Permission, error) {
	query := sqlite_getPermissionsByUserIDAndPermissionNames
	var queryParams []interface{}
	queryParams = append(queryParams, userID)
	if len(permissionnames) > 0 {
		for _, v := range permissionnames {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:permissionnames*/?", strings.Repeat(",?", len(permissionnames))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:permissionnames*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getPermissionsWithPagination = `-- name: GetPermissionsWithPagination :many
SELECT id, name, description FROM permissions
ORDER BY id
LIMIT ? OFFSET ?
`

func (q *SQLiteQueries) GetPermissionsWithPagination(ctx context.Context, limit uint64, offset uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getPermissionsWithPagination, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}



const sqlite_userByEmail = `-- name: UserByEmail :one
SELECT id, created_at, updated_at, email, username, password, first_name, last_name, is_administrator, is_active FROM users WHERE email = ?
`

func (q *SQLiteQueries) UserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, sqlite_userByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.IsAdministrator,
		&i.IsActive,
	)
	return i, err
}

const sqlite_userByID = `-- name: UserByID :one
SELECT id, created_at, updated_at, email, username, password, first_name, last_name, is_administrator, is_active FROM users WHERE id = ?
`

func (q *SQLiteQueries) UserByID(ctx context.Context, id uint64) (User, error) {
	row := q.db.QueryRowContext(ctx, sqlite_userByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.IsAdministrator,
		&i.IsActive,
	)
	return i, err
}

const sqlite_userByUsername = `-- name: UserByUsername :one
SELECT id, created_at, updated_at, email, username, password, first_name, last_name, is_administrator, is_active FROM users WHERE username = ?
`

func (q *SQLiteQueries) UserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, sqlite_userByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.FirstName,
		&i.LastName,
		&i.IsAdministrator,
		&i.IsActive,
	)
	return i, err
}


const sqlite_getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active,
    g.id AS group_id, g.name AS group_name, g.description AS group_description,
    p.id AS permission_id, p.name AS permission_name, p.description AS permission_description
FROM
    users u
JOIN
    user_groups ug ON u.id = ug.user_id
JOIN
    groups g ON ug.group_id = g.id
JOIN
    group_permissions gp ON g.id = gp.group_id
JOIN
    permissions p ON gp.permission_id = p.id
WHERE
    u.email = ?
ORDER BY
    u.id, g.name, p.name
LIMIT 1
`

func (q *SQLiteQueries) GetUserByEmail(ctx context.Context, email string) (UserRow, error) {
	row := q.db.QueryRowContext(ctx, sqlite_getUserByEmail, email)
	var i UserRow
	err := row.Scan(
		&i.User.ID,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.Username,
		&i.User.Password,
		&i.User.FirstName,
		&i.User.LastName,
		&i.User.IsAdministrator,
		&i.User.IsActive,
		&i.GroupID,
		&i.GroupName,
		&i.GroupDescription,
		&i.PermissionID,
		&i.PermissionName,
		&i.PermissionDescription,
	)
	return i, err
}

const sqlite_getUserById = `-- name: GetUserById :many
SELECT
    u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active,
    g.id AS group_id, g.name AS group_name, g.description AS group_description,
    p.id AS permission_id, p.name AS permission_name, p.description AS permission_description
FROM
    users u
JOIN
    user_groups ug ON u.id = ug.user_id
JOIN
    groups g ON ug.group_id = g.id
JOIN
    group_permissions gp ON g.id = gp.group_id
JOIN
    permissions p ON gp.permission_id = p.id
WHERE
    u.id = ?
ORDER BY
    u.id, g.name, p.name
`


func (q *SQLiteQueries) GetUserById(ctx context.Context, id uint64) ([]UserRow, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getUserById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRow
	for rows.Next() {
		var i UserRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.Email,
			&i.User.Username,
			&i.User.Password,
			&i.User.FirstName,
			&i.User.LastName,
			&i.User.IsAdministrator,
			&i.User.IsActive,
			&i.GroupID,
			&i.GroupName,
			&i.GroupDescription,
			&i.PermissionID,
			&i.PermissionName,
			&i.PermissionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getUserByName = `-- name: GetUserByName :one
SELECT
    u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active,
    g.id AS group_id, g.name AS group_name, g.description AS group_description,
    p.id AS permission_id, p.name AS permission_name, p.description AS permission_description
FROM
    users u
JOIN
    user_groups ug ON u.id = ug.user_id
JOIN
    groups g ON ug.group_id = g.id
JOIN
    group_permissions gp ON g.id = gp.group_id
JOIN
    permissions p ON gp.permission_id = p.id
WHERE
    u.username = ?
ORDER BY
    u.id
LIMIT 1
`

func (q *SQLiteQueries) GetUserByName(ctx context.Context, username string) (UserRow, error) {
	row := q.db.QueryRowContext(ctx, sqlite_getUserByName, username)
	var i UserRow
	err := row.Scan(
		&i.User.ID,
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.Email,
		&i.User.Username,
		&i.User.Password,
		&i.User.FirstName,
		&i.User.LastName,
		&i.User.IsAdministrator,
		&i.User.IsActive,
		&i.GroupID,
		&i.GroupName,
		&i.GroupDescription,
		&i.PermissionID,
		&i.PermissionName,
		&i.PermissionDescription,
	)
	return i, err
}

const sqlite_getUsersByPermissionID = `-- name: GetUsersByPermissionID :many
SELECT DISTINCT u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active
FROM users u
JOIN user_groups ug ON u.id = ug.user_id
JOIN group_permissions gp ON ug.group_id = gp.group_id
WHERE gp.permission_id = ?
`

func (q *SQLiteQueries) GetUsersByPermissionID(ctx context.Context, permissionID uint64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getUsersByPermissionID, permissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.FirstName,
			&i.LastName,
			&i.IsAdministrator,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_getUsersWithPagination = `-- name: GetUsersWithPagination :many
SELECT id, created_at, updated_at, email, username, password, first_name, last_name, is_administrator, is_active FROM users
ORDER BY id
LIMIT ? OFFSET ?
`

func (q *SQLiteQueries) GetUsersWithPagination(ctx context.Context, limit uint64, offset uint64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_getUsersWithPagination, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User = make([]User, 0)
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.FirstName,
			&i.LastName,
			&i.IsAdministrator,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_groupsDoNotBelongTo = `-- name: GroupsDoNotBelongTo :many
SELECT g.id, g.name, g.description
FROM groups g
WHERE g.id NOT IN (
    SELECT ug.group_id
    FROM user_groups ug
    WHERE ug.user_id = ?
)
`

func (q *SQLiteQueries) GroupsDoNotBelongTo(ctx context.Context, userID uint64) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_groupsDoNotBelongTo, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Group
	for rows.Next() {
		var i Group
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_listPermissionsInGroup = `-- name: ListPermissionsInGroup :many
SELECT p.id, p.name, p.description FROM permissions p JOIN group_permissions gp ON p.id = gp.permission_id WHERE gp.group_id = ?
`

func (q *SQLiteQueries) ListPermissionsInGroup(ctx context.Context, groupID uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_listPermissionsInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_listUsersInGroup = `-- name: ListUsersInGroup :many
SELECT u.id, u.created_at, u.updated_at, u.email, u.username, u.password, u.first_name, u.last_name, u.is_administrator, u.is_active FROM users u JOIN user_groups ug ON u.id = ug.user_id WHERE ug.group_id = ?
`

func (q *SQLiteQueries) ListUsersInGroup(ctx context.Context, groupID uint64) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_listUsersInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.FirstName,
			&i.LastName,
			&i.IsAdministrator,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_permissionsNotInGroup = `-- name: PermissionsNotInGroup :many
SELECT p.id, p.name, p.description
FROM permissions p
WHERE p.id NOT IN (
    SELECT permission_id
    FROM group_permissions
    WHERE group_id = ?
)
`

func (q *SQLiteQueries) PermissionsNotInGroup(ctx context.Context, groupID uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_permissionsNotInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_permissionsNotInUser = `-- name: PermissionsNotInUser :many
SELECT p.id, p.name, p.description
FROM permissions p
WHERE p.id NOT IN (
    SELECT gp.permission_id
    FROM user_groups ug
    JOIN group_permissions gp ON ug.group_id = gp.group_id
    WHERE ug.user_id = ?
)
`

func (q *SQLiteQueries) PermissionsNotInUser(ctx context.Context, userID uint64) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, sqlite_permissionsNotInUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sqlite_removePermissionFromGroup = `-- name: RemovePermissionFromGroup :exec
DELETE FROM group_permissions WHERE group_id = ? AND permission_id = ?
`

func (q *SQLiteQueries) RemovePermissionFromGroup(ctx context.Context, groupID uint64, permissionID uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_removePermissionFromGroup, groupID, permissionID)
	return err
}

const sqlite_removeUserFromGroup = `-- name: RemoveUserFromGroup :exec
DELETE FROM user_groups WHERE user_id = ? AND group_id = ?
`

func (q *SQLiteQueries) RemoveUserFromGroup(ctx context.Context, userID uint64, groupID uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_removeUserFromGroup, userID, groupID)
	return err
}

const sqlite_updateGroup = `-- name: UpdateGroup :exec
UPDATE groups SET name = ?, description = ? WHERE id = ?
`

func (q *SQLiteQueries) UpdateGroup(ctx context.Context, name string, description string, iD uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_updateGroup, name, description, iD)
	return err
}

const sqlite_updatePermission = `-- name: UpdatePermission :exec
UPDATE permissions SET name = ?, description = ? WHERE id = ?
`

func (q *SQLiteQueries) UpdatePermission(ctx context.Context, name string, description string, iD uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_updatePermission, name, description, iD)
	return err
}

const sqlite_updateUser = `-- name: UpdateUser :exec
UPDATE users SET email = ?, username = ?, password = ?, first_name = ?, last_name = ?, is_administrator = ?, is_active = ? WHERE id = ?
`

func (q *SQLiteQueries) UpdateUser(ctx context.Context, email string, username string, password string, firstName string, lastName string, isAdministrator bool, isActive bool, iD uint64) error {
	_, err := q.db.ExecContext(ctx, sqlite_updateUser,
		email,
		username,
		password,
		firstName,
		lastName,
		isAdministrator,
		isActive,
		iD,
	)
	return err
}
