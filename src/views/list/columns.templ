package list

import (
	"context"
    "github.com/Nigel2392/go-django/src/core/attrs"
    "github.com/Nigel2392/go-django/src/core/assert"
	"html/template"
	"time"
	"net/http"
	"github.com/Nigel2392/go-django/src/core/trans"
	"github.com/Nigel2392/go-django/queries/src/drivers"
	"reflect"
	"strconv"
	"fmt"
	"github.com/Nigel2392/go-django/src/internal/django_reflect"
	"github.com/Nigel2392/go-django/src/forms/widgets"
	"github.com/Nigel2392/go-django/src/forms/media"
	"github.com/Nigel2392/go-django/src/forms/fields"
	"github.com/Nigel2392/go-django/src/forms"
	"maps"
)

templ input(typ string, name string, value any, atts map[string]any) {
	<input { atts... } type={ typ } name={ name } value={ attrs.ToString(value) } />
}

func getComponent[T attrs.Definer](r *http.Request, defs attrs.Definitions, row T, value any) templ.Component {
	var rV = reflect.ValueOf(value)
	switch val := value.(type) {
	case string:
		return templ.Raw(val)
	case template.HTML:
		return templ.Raw(string(val))
	case attrs.Definer:
		return templ.Raw(attrs.ToString(val))
	case templ.Component:
		return val
	}

	if val, ok := value.(interface{ Time() time.Time }); ok {
		var t = val.Time()
		var col = &dateTimeColumn[T]{
			fmt: trans.SHORT_TIME_FORMAT,
			data: func(r *http.Request, defs attrs.Definitions, row T) time.Time {
				return t
			},
		}
		return col.Component(r, defs, row)
	}

	switch rV.Kind() {
	case reflect.String:
		return templ.Raw(rV.String())
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return templ.Raw(fmt.Sprintf("%d", rV.Interface()))
	case reflect.Float32, reflect.Float64:
		return templ.Raw(strconv.FormatFloat(rV.Float(), 'f', -1, 64))
	case reflect.Bool:
		var col = &booleanColumn[T]{data: func(r *http.Request, defs attrs.Definitions, row T) bool {
			return rV.Bool()
		}}
		return col.Component(r, defs, row)
	}

    var rTyp = rV.Type()
	if (rTyp.Kind() == reflect.Slice || rTyp.Kind() == reflect.Array) && rTyp.Elem().Kind() == reflect.Uint8 {
		var length = rV.Len()
		// write byte size
		if length < 1024 {
			return templ.Raw(fmt.Sprintf("%d B", length))
		}
		if length < 1024*1024 {
			return templ.Raw(fmt.Sprintf("%.1f KiB", float64(length)/1024))
		}
		if length < 1024*1024*1024 {
			return templ.Raw(fmt.Sprintf("%.1f MiB", float64(length)/1024/1024))
		}
		return templ.Raw(fmt.Sprintf("%.1f GiB", float64(length)/1024/1024/1024))
	}

	return templ.Raw(attrs.ToString(value))
}

type booleanColumn[T attrs.Definer] struct {
	header func(ctx context.Context) string
	fieldName string
	data      func(r *http.Request, defs attrs.Definitions, row T) bool
}

templ (c *booleanColumn[T]) Header(r *http.Request) {
	{{ assert.False(c.header == nil, "Column header is nil") }}
	{ c.header(ctx) }
}

func (c *booleanColumn[T]) FieldName() string {
	return c.fieldName
}

func (c *booleanColumn[T]) Attributes(r *http.Request, defs attrs.Definitions, row T, colIndex, colCount int) map[string]any {
	return nil
}

func (c *booleanColumn[T]) getData(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.fieldName != "" {
		var field, ok = defs.Field(c.fieldName)
		assert.True(
			ok,
			"Field %q does not exist", c.fieldName,
		)

		var val, err = field.Value()
		assert.True(
			err == nil,
			"Field %q (%T) Value method has returned an error: %v", 
			c.fieldName, field, err,
		)

		var rV = reflect.ValueOf(val)
		switch rV.Kind() {
		case reflect.Bool:
			return rV.Bool()
		case reflect.String:
			return rV.String() != ""
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			return rV.Int() != 0
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			return rV.Uint() != 0
		case reflect.Float32, reflect.Float64:
			return rV.Float() != 0
		default:
			return !attrs.IsZero(val)
		}
	}

	if c.data != nil {
		return c.data(r, defs, row)
	}

	return false
}

templ (c *booleanColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	if c.getData(r, defs, row) {
		<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="list-check-yes" viewBox="0 0 16 16">
    		<!--! The MIT License (MIT) -->
    		<!--! Copyright (c) 2011-2024 The Bootstrap Authors -->
		 	<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>
		 	<path d="m10.97 4.97-.02.022-3.473 4.425-2.093-2.094a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05"/>
		</svg>
	} else {
		<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="list-check-no" viewBox="0 0 16 16">
    		<!--! The MIT License (MIT) -->
    		<!--! Copyright (c) 2011-2024 The Bootstrap Authors -->
		  	<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>
		  	<path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"/>
		</svg>
	}
}

func BooleanColumnFunc[T attrs.Definer](header func(ctx context.Context) string, data func(r *http.Request, defs attrs.Definitions, row T) bool) ListColumn[T] {
	return &booleanColumn[T]{
		header:    header,
		data:     data,
	}
}

func BooleanFieldColumn[T attrs.Definer](header func(ctx context.Context) string, fieldName string) ListColumn[T] {
	return &booleanColumn[T]{
		header:    header,
		fieldName: fieldName,
	}
}

type dateTimeColumn[T attrs.Definer] struct {
	fmt    string
	header func(ctx context.Context) string
	fieldName string
	data   func(r *http.Request, defs attrs.Definitions, row T) time.Time
}

func DateTimeColumnFunc[T attrs.Definer](fmt string, header func(ctx context.Context) string, data func(r *http.Request, defs attrs.Definitions, row T) time.Time) ListColumn[T] {
	return &dateTimeColumn[T]{
		fmt:    fmt,
		header: header,
		data:   data,
	}
}

func DateTimeFieldColumn[T attrs.Definer](fmt string, header func(ctx context.Context) string, fieldName string) ListColumn[T] {
	return &dateTimeColumn[T]{
		fmt:      fmt,
		header:   header,
		fieldName: fieldName,
	}
}

func (c *dateTimeColumn[T]) Attributes(r *http.Request, defs attrs.Definitions, row T, colIndex, colCount int) map[string]any {
	return nil
}

func (c *dateTimeColumn[T]) FieldName() string {
	return c.fieldName
}

func (c *dateTimeColumn[T]) getData(r *http.Request, defs attrs.Definitions, row T) time.Time {
	if c.fieldName != "" {
		var field, ok = defs.Field(c.fieldName)
		assert.True(
			ok,
			"Field %q does not exist", c.fieldName,
		)

		var val, err = field.Value()
		assert.True(
			err == nil,
			"Field %q (%T) Value method has returned an error: %v",
			c.fieldName, field, err,
		)

		var rV = reflect.ValueOf(val)
		var timeTyp = reflect.TypeOf(time.Time{})
		if rV.Type().ConvertibleTo(timeTyp) {
			return rV.Convert(timeTyp).Interface().(time.Time)
		}

		if rV.Type() == timeTyp {
			return rV.Interface().(time.Time)
		}
	}

	if c.data != nil {
		return c.data(r, defs, row)
	}

	return time.Time{}
}

templ (c *dateTimeColumn[T]) Header(r *http.Request) {
	{{ assert.False(c.header == nil, "Column header is nil") }}
	{ c.header(ctx) }
}

templ (c *dateTimeColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var value = c.getData(r, defs, row) }}
	{ trans.Time(r.Context(), value, c.fmt) }
}

type wrappedColumn[T1, T2 attrs.Definer] struct {
	ListColumn[T2]
	attrs func(r *http.Request, defs attrs.Definitions, row T2) map[string]any
	fieldName string
}

func (c *wrappedColumn[T, T2]) FieldName() string {
	if c.fieldName != "" {
		return c.fieldName
	}
	return c.ListColumn.FieldName()
}

func (c *wrappedColumn[T, T2]) getAttrs(r *http.Request, defs attrs.Definitions, row T2) map[string]any {
	if c.attrs != nil {
		return c.attrs(r, defs, row)
	}
	return make(map[string]any)
}

func (c *wrappedColumn[T, T2]) Attributes(r *http.Request, defs attrs.Definitions, row T, colIndex, colCount int) map[string]any {
	var attrs = c.ListColumn.Attributes(r, defs, any(row).(T2), colIndex, colCount)
	if attrs == nil {
		attrs = make(map[string]any)
	}
	maps.Copy(attrs, c.getAttrs(r, defs, any(row).(T2)))
	return attrs
}

func (c *wrappedColumn[T, T2]) FormField(r *http.Request, row T) fields.Field {
	if editable, ok := c.ListColumn.(ListEditableColumn[T2]); ok {
		return editable.FormField(r, any(row).(T2))
	}
	return nil
}

func (c *wrappedColumn[T, T2]) Media(defs attrs.StaticDefinitions) media.Media {
	if m, ok := c.ListColumn.(media.MediaDefiner); ok {
		return m.Media()
	}
	if m, ok := c.ListColumn.(ListMediaColumn); ok {
		return m.Media(defs)
	}
	return nil
}

templ (c *wrappedColumn[T1, T2]) Component(r *http.Request, defs attrs.Definitions, row T1) {
	@c.ListColumn.Component(r, defs, any(row).(T2))
}

func ChangeColumnType[T1, T2 attrs.Definer](col ListColumn[T2], args ...any) ListColumn[T1] {
	var (
		attrMap map[string]any
		field   string
	)

	for i, arg := range args {
		if i > 1 {
			assert.Fail("Too many arguments provided, expected at most 2: %d", len(args))
		}
		switch v := arg.(type) {
		case map[string]any:
			maps.Copy(attrMap, v)
		case string:
			field = v
		default:
			assert.Fail("Unsupported argument type, expected map[string]any or string")
		}
	}

	return &wrappedColumn[T1, T2]{
		ListColumn: col,
		fieldName: field,
		attrs: func(r *http.Request, defs attrs.Definitions, row T2) map[string]any {
			var attrsMap = make(map[string]any)
			maps.Copy(attrsMap, attrMap)
			return attrsMap
		},
	}
}

type funcColumn[T attrs.Definer] struct {
	header    func(ctx context.Context) string
	data      func(r *http.Request, defs attrs.Definitions, row T) interface{}
}

func (c *funcColumn[T]) FieldName() string {
	return ""
}

func (c *funcColumn[T]) Attributes(r *http.Request, defs attrs.Definitions, row T, colIndex, colCount int) map[string]any {
	return nil
}

templ (c *funcColumn[T]) Header(r *http.Request) {
	{{ assert.False(c.header == nil, "Column header is nil") }}
    { c.header(ctx) }
}

templ (c *funcColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	@getComponent(r, defs, row, c.data(r, defs, row))
}

func FuncColumn[T attrs.Definer](header func(ctx context.Context) string, data func(r *http.Request, defs attrs.Definitions, row T) interface{}) ListColumn[T] {
	return &funcColumn[T]{header, data}
}

type fieldColumn[T attrs.Definer, VAL any] struct {
	fieldName string
	header    func(ctx context.Context) string
	process   func(r *http.Request, defs attrs.Definitions, row T, value VAL) any
}

func (c *fieldColumn[T, VAL]) FieldName() string {
	return c.fieldName
}

func (c *fieldColumn[T, VAL]) Attributes(r *http.Request, defs attrs.Definitions, row T, colIndex, colCount int) map[string]any {
	return nil
}

templ (c *fieldColumn[T, VAL]) Header(r *http.Request) {
	{{ assert.False(c.header == nil, "Column header is nil") }}
    { c.header(ctx) }
}

var __reflect_type_any = reflect.TypeOf((*any)(nil)).Elem()

func (c *fieldColumn[T, VAL]) data(r *http.Request, defs attrs.Definitions, row T) interface{} {
	var field, ok = defs.Field(c.fieldName)
	assert.False(
		!ok,
		"Field %q does not exist", c.fieldName,
	)

	if field == nil {
		if c.process != nil {
			return c.process(r, defs, row, *new(VAL))
		}
		return nil
	}

	var fieldValue, err = field.Value()
	assert.True(
		err == nil,
		"Field %q (%T) Value method has returned an error: %v",
		c.fieldName, field, err,
	)

	var rV = reflect.ValueOf(fieldValue)
	var _dst VAL
	var dstTyp = reflect.TypeOf(_dst)

	if dstTyp == __reflect_type_any || dstTyp == reflect.TypeOf(nil) {
		goto skipConversionChecks
	}

	switch {
	case rV.Type().ConvertibleTo(dstTyp):
		fieldValue = rV.Convert(dstTyp).Interface()
	case rV.Type() == dstTyp:
		fieldValue = rV.Interface()
	case dstTyp.Kind() == reflect.Interface && rV.Type().Implements(dstTyp):
		fieldValue = rV.Interface()
	default:
		assert.Fail(
			"Field %q (%T) has an unsupported type: %v",
			c.fieldName, field, fieldValue,
		)
	}

skipConversionChecks:
	if c.process != nil {
		fieldValue = c.process(r, defs, row, fieldValue.(VAL))
	}

	switch f := fieldValue.(type) {
		case time.Time:
			return trans.Time(r.Context(), f, trans.LONG_TIME_FORMAT)
		case drivers.DateTime:
			return trans.Time(r.Context(), time.Time(f), trans.LONG_TIME_FORMAT)
		case drivers.LocalTime:
			return trans.Time(r.Context(), time.Time(f), trans.SHORT_TIME_FORMAT)
		case drivers.Timestamp:
			return trans.Time(r.Context(), time.Time(f), trans.SHORT_TIME_FORMAT)
	}

	return fieldValue
}

templ (c *fieldColumn[T, VAL]) Component(r *http.Request, defs attrs.Definitions, row T) {
	@getComponent(r, defs, row, c.data(r, defs, row))
}

func FieldColumn[T attrs.Definer](header func(ctx context.Context) string, fieldName string) ListColumn[T] {
	return &fieldColumn[T, any]{
		fieldName: fieldName,
		header:    header,
	}
}

func ProcessableFieldColumn[T attrs.Definer, VAL any](header func(ctx context.Context) string, fieldName string, process func(r *http.Request, defs attrs.Definitions, row T, value VAL) any) ListColumn[T] {
	return &fieldColumn[T, VAL]{
		fieldName: fieldName,
		header:    header,
		process:  process,
	}
}

type titleFieldColumn[T attrs.Definer] struct {
	wrapped ListColumn[T]
	getURL  func(r *http.Request, defs attrs.Definitions, row T) string
}

func (c *titleFieldColumn[T]) Attributes(r *http.Request, defs attrs.Definitions, row T, colIndex, colCount int) map[string]any {
	return c.wrapped.Attributes(r, defs, row, colIndex, colCount)
}

func (c *titleFieldColumn[T]) Media(defs attrs.StaticDefinitions) media.Media {
	if m, ok := c.wrapped.(media.MediaDefiner); ok {
		return m.Media()
	}
	if f, ok := c.wrapped.(ListMediaColumn); ok {
		return f.Media(defs)
	}
	return nil
}

func (c *titleFieldColumn[T]) FieldName() string {
	return c.wrapped.FieldName()
}

templ (c *titleFieldColumn[T]) Header(r *http.Request) {
	<div class="list-title">
		@c.wrapped.Header(r)
	</div>
}

templ (c *titleFieldColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var url = templ.SafeURL(c.getURL(r, defs, row))}}
	<div class="list-title">
		if url == "" {
			@c.wrapped.Component(r, defs, row)
		} else {
			<a href={ url }>
				@c.wrapped.Component(r, defs, row)
			</a>
		}
	</div>
}

func TitleFieldColumn[T attrs.Definer](wraps ListColumn[T], getURL func(r *http.Request, defs attrs.Definitions, row T) string) ListColumn[T] {
	return &titleFieldColumn[T]{
		wrapped: wraps,
		getURL:  getURL,
	}
}

type htmlColumn[T attrs.Definer] struct {
	*fieldColumn[T, any]
	getHTML func(r *http.Request, defs attrs.Definitions, row T) template.HTML
}

templ (c *htmlColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var html = c.getHTML(r, defs, row) }}
	@templ.Raw(html)
}

func HTMLColumn[T attrs.Definer](header func(ctx context.Context) string, getHTML func(r *http.Request, defs attrs.Definitions, row T) template.HTML) ListColumn[T] {
	return &htmlColumn[T]{
		fieldColumn: &fieldColumn[T, any]{header: header},
		getHTML:    getHTML,
	}
}

func HTMLFieldColumn[T attrs.Definer](header func(ctx context.Context) string, fieldName string) ListColumn[T] {
	var fc = &fieldColumn[T, any]{header: header, fieldName: fieldName}
	return &htmlColumn[T]{
		fieldColumn: fc,
		getHTML: func(r *http.Request, defs attrs.Definitions, row T) template.HTML {
			var val = fc.data(r, defs, row)
			return template.HTML(attrs.ToString(val))
		},
	}
}

type linkColumn[T attrs.Definer] struct {
	fieldColumn[T, any]
	getURL func(r *http.Request, defs attrs.Definitions, row T) string
}

templ (c *linkColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var url = templ.SafeURL(c.getURL(r, defs, row))}}
	if url == "" {
		@c.fieldColumn.Component(r, defs, row)
	} else {
		<a href={ url }>
			@c.fieldColumn.Component(r, defs, row)
		</a>
	}
}

func LinkColumn[T attrs.Definer](header func(ctx context.Context) string, fieldName string, getURL func(r *http.Request, defs attrs.Definitions, row T) string) ListColumn[T] {
	return &linkColumn[T]{
		fieldColumn: fieldColumn[T, any]{
			header:   header,
			fieldName: fieldName,
		},
		getURL:     getURL,
	}
}

type rowSelectColumn[T attrs.Definer] struct {
	formName      string
	isChecked     func(r *http.Request, defs attrs.Definitions, row T) bool
	inputAttrs    map[string]any
	hasPermission func(r *http.Request, defs attrs.Definitions, row T) bool
	ListColumn[T]
}

func (c *rowSelectColumn[T]) checked(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.isChecked != nil {
		return c.isChecked(r, defs, row)
	}

	return false
}

func (c *rowSelectColumn[T]) permitted(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.hasPermission != nil {
		return c.hasPermission(r, defs, row)
	}

	return true
}

func (c *rowSelectColumn[T]) Media(defs attrs.StaticDefinitions) media.Media {
	if m, ok := c.ListColumn.(media.MediaDefiner); ok {
		return m.Media()
	}
	if f, ok := c.ListColumn.(ListMediaColumn); ok {
		return f.Media(defs)
	}
	return nil
}

templ (c *rowSelectColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	if !AllowListRowSelect(r.Context()) || !c.permitted(r, defs, row) {
		@c.ListColumn.Component(r, defs, row)
		{{ return }}
	}
	<div class="list-checkbox-wrapper">
		<div class="list-checkbox">
			<input { c.inputAttrs... } type="checkbox" class="list-checkbox__input" name={ c.formName } value={ attrs.ToString(attrs.PrimaryKey(row)) } checked?={ c.checked(r, defs, row) } />
		</div>
		<div class="list-checkbox__column">
			@c.ListColumn.Component(r, defs, row)
		</div>
	</div>
}

type BoundBoolFunc[T attrs.Definer] = func(r *http.Request, defs attrs.Definitions, row T) bool

func RowSelectColumn[T attrs.Definer](formName string, isChecked, hasPermission BoundBoolFunc[T], wraps ListColumn[T], attrs map[string]any) ListColumn[T] {
	return &rowSelectColumn[T]{
		formName:      formName,
		isChecked: isChecked,
		hasPermission: hasPermission,
		ListColumn: wraps,
		inputAttrs:  attrs,
	}
}

type fieldCheckbox[T attrs.Definer] struct {
	fieldColumn[T, any]
	inputAttrs    map[string]any
	hasPermission BoundBoolFunc[T]
}

func FieldCheckbox[T attrs.Definer](header func(ctx context.Context) string, fieldName string, hasPermission BoundBoolFunc[T]) ListColumn[T] {
	return &fieldCheckbox[T]{
		fieldColumn: fieldColumn[T, any]{
			header:   header,
			fieldName: fieldName,
		},
		hasPermission: hasPermission,
	}
}

func (c *fieldCheckbox[T]) permitted(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.hasPermission != nil {
		return c.hasPermission(r, defs, row)
	}
	return true
}

templ (c *fieldCheckbox[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	if !AllowListEdit(r.Context()) || !c.permitted(r, defs, row) {
		@c.fieldColumn.Component(r, defs, row)
		{{ return }}
	}
	<div class="list-checkbox-wrapper">
		<div class="list-checkbox">
			<input { c.inputAttrs... } type="checkbox" class="list-checkbox__input" name={ c.fieldColumn.fieldName } value="1" checked?={ !django_reflect.IsZero(c.fieldColumn.data(r, defs, row)) } />
		</div>
	</div>
}

type listEditableColumn[T attrs.Definer] struct {
	header        func(ctx context.Context) string
	config       EditableColumnConfig
}

func (c *listEditableColumn[T]) permitted(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.config.HasPermission != nil {
		return c.config.HasPermission(r, defs, row)
	}
	return true
}

func (c *listEditableColumn[T]) value(r *http.Request, defs attrs.Definitions, row T) interface{} {
	var field, ok = defs.Field(c.config.FieldName)
	assert.True(
		ok,
		"Field %q does not exist", c.config.FieldName,
	)

	var d = field.GetValue()
	if attrs.IsZero(d) {
		d = field.GetDefault()
	}

	if c.config.Widget != nil {
		d = c.config.Widget.ValueToForm(d)
	}

	return d
}

func (c *listEditableColumn[T]) Attributes(r *http.Request, defs attrs.Definitions, row T, colIndex, colCount int) map[string]any {
	return c.config.ColumnAttrs
}

func (c *listEditableColumn[T]) FieldName() string {
	return c.config.FieldName
}

func (c *listEditableColumn[T]) FormField(r *http.Request, row T) fields.Field {
	var meta = attrs.GetModelMeta(row)
	var defs = meta.Definitions()
	var attrField, ok = defs.Field(c.config.FieldName)
	if !ok {
		assert.Fail("Field %q does not exist", c.config.FieldName)
		return nil
	}
	
	return attrField.FormField()
}

func (c *listEditableColumn[T]) Media(defs attrs.StaticDefinitions) media.Media {
	if c.config.Widget != nil {
		return c.config.Widget.Media()
	}

	var field, ok = defs.Field(c.config.FieldName)
	if !ok {
		assert.Fail("Field %q does not exist", c.config.FieldName)
		return media.NewMedia()
	}

	var formField = field.FormField()
	return formField.Widget().Media()
}

templ (c *listEditableColumn[T]) Header(r *http.Request) {
	{{ assert.False(c.header == nil, "Column header is nil") }}
	{ c.header(ctx) }
}

templ (c *listEditableColumn[T]) EditableComponent(r *http.Request, defs attrs.Definitions, row T, form forms.Form, field *forms.BoundFormField) {
	if field == nil || form == nil || !AllowListEdit(r.Context()) || !c.permitted(r, defs, row) {
		@getComponent(r, defs, row, c.value(r, defs, row))
		{{ return }}
	}
	<div class="list-editable">
		if !forms.HasErrors(form) && field.FormValue == nil {
			{{ field.FormValue = c.value(r, defs, row) }}
		}
		@templ.Raw(string(field.Field()))
	</div>
}

templ (c *listEditableColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	@getComponent(r, defs, row, c.value(r, defs, row))
}

type EditableColumnConfig struct {
	FieldName     string
	Widget        widgets.Widget
	WidgetAttrs   map[string]string
	HasPermission BoundBoolFunc[attrs.Definer]
	ColumnAttrs   map[string]any
}

func EditableColumn[T attrs.Definer](header func(ctx context.Context) string, config EditableColumnConfig) ListColumn[T] {
	return &listEditableColumn[T]{
		header: header,
		config: config,
	}
}

func Column[T attrs.Definer](header func(ctx context.Context) string, getter any) ListColumn[T] {
	switch g := getter.(type) {
	case func(r *http.Request, defs attrs.Definitions, row T) interface{}:
		return &funcColumn[T]{header, g}
	case string:
		return &fieldColumn[T, any]{
			header:   header,
			fieldName: g,
		}
	case ListColumn[T]:
		return g
	default:
		assert.Fail("Invalid column getter type")
		return nil
	}
}
