package list

import (
	"context"
    "github.com/Nigel2392/go-django/src/core/attrs"
    "github.com/Nigel2392/go-django/src/core/assert"
	"html/template"
	"time"
	"net/http"
	"github.com/Nigel2392/go-django/src/core/trans"
	"github.com/Nigel2392/go-django/queries/src/drivers"
	"reflect"
	"strconv"
	"fmt"
	"github.com/Nigel2392/go-django/src/internal/django_reflect"
	"github.com/Nigel2392/go-django/src/forms/widgets"
	"github.com/Nigel2392/go-django/src/forms/media"
	"github.com/Nigel2392/go-django/src/forms/fields"
	"github.com/Nigel2392/go-django/src/forms"
)

templ input(typ string, name string, value any, atts map[string]any) {
	<input { atts... } type={ typ } name={ name } value={ attrs.ToString(value) } />
}

func getComponent[T attrs.Definer](r *http.Request, defs attrs.Definitions, row T, value any) templ.Component {
	var rV = reflect.ValueOf(value)
	switch val := value.(type) {
	case string:
		return templ.Raw(val)
	case template.HTML:
		return templ.Raw(string(val))
	case attrs.Definer:
		return templ.Raw(attrs.ToString(val))
	}

	if val, ok := value.(interface{ Time() time.Time }); ok {
		var t = val.Time()
		var col = &dateTimeColumn[T]{
			fmt: trans.SHORT_TIME_FORMAT,
			data: func(r *http.Request, defs attrs.Definitions, row T) time.Time {
				return t
			},
		}
		return col.Component(r, defs, row)
	}

	switch rV.Kind() {
	case reflect.String:
		return templ.Raw(rV.String())
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return templ.Raw(fmt.Sprintf("%d", rV.Interface()))
	case reflect.Float32, reflect.Float64:
		return templ.Raw(strconv.FormatFloat(rV.Float(), 'f', -1, 64))
	case reflect.Bool:
		var col = &booleanColumn[T]{data: func(r *http.Request, defs attrs.Definitions, row T) bool {
			return rV.Bool()
		}}
		return col.Component(r, defs, row)
	}

    var rTyp = rV.Type()
	if (rTyp.Kind() == reflect.Slice || rTyp.Kind() == reflect.Array) && rTyp.Elem().Kind() == reflect.Uint8 {
		var length = rV.Len()
		// write byte size
		if length < 1024 {
			return templ.Raw(fmt.Sprintf("%d B", length))
		}
		if length < 1024*1024 {
			return templ.Raw(fmt.Sprintf("%.1f KiB", float64(length)/1024))
		}
		if length < 1024*1024*1024 {
			return templ.Raw(fmt.Sprintf("%.1f MiB", float64(length)/1024/1024))
		}
		return templ.Raw(fmt.Sprintf("%.1f GiB", float64(length)/1024/1024/1024))
	}

	return templ.Raw(attrs.ToString(value))
}

type booleanColumn[T attrs.Definer] struct {
	header func(ctx context.Context) string
	data   func(r *http.Request, defs attrs.Definitions, row T) bool
}

templ (c *booleanColumn[T]) Header() {
	{{ assert.False(c.header == nil, "Column header is nil") }}
	{ c.header(ctx) }
}

templ (c *booleanColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	if c.data(r, defs, row) {
		<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="list-check-yes" viewBox="0 0 16 16">
    		<!--! The MIT License (MIT) -->
    		<!--! Copyright (c) 2011-2024 The Bootstrap Authors -->
		 	<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>
		 	<path d="m10.97 4.97-.02.022-3.473 4.425-2.093-2.094a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05"/>
		</svg>
	} else {
		<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="list-check-no" viewBox="0 0 16 16">
    		<!--! The MIT License (MIT) -->
    		<!--! Copyright (c) 2011-2024 The Bootstrap Authors -->
		  	<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>
		  	<path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"/>
		</svg>
	}
}

func BooleanColumn[T attrs.Definer](header func(ctx context.Context) string, data func(r *http.Request, defs attrs.Definitions, row T) bool) ListColumn[T] {
	return &booleanColumn[T]{header, data}
}

type dateTimeColumn[T attrs.Definer] struct {
	fmt    string
	header func(ctx context.Context) string
	data   func(r *http.Request, defs attrs.Definitions, row T) time.Time
}

func DateTimeColumn[T attrs.Definer](fmt string, header func(ctx context.Context) string, data func(r *http.Request, defs attrs.Definitions, row T) time.Time) ListColumn[T] {
	return &dateTimeColumn[T]{fmt, header, data}
}

templ (c *dateTimeColumn[T]) Header() {
	{{ assert.False(c.header == nil, "Column header is nil") }}
	{ c.header(ctx) }
}

templ (c *dateTimeColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var value = c.data(r, defs, row) }}
	{ trans.Time(r.Context(), value, c.fmt) }
}

type wrappedColumn[T1, T2 attrs.Definer] struct {
	ListColumn[T2]
}

templ (c *wrappedColumn[T1, T2]) Component(r *http.Request, defs attrs.Definitions, row T1) {
	@c.ListColumn.Component(r, defs, any(row).(T2))
}

func ChangeColumnType[T1, T2 attrs.Definer](col ListColumn[T2]) ListColumn[T1] {
	return &wrappedColumn[T1, T2]{col}
}

type funcColumn[T attrs.Definer] struct {
	header func(ctx context.Context) string
	data   func(r *http.Request, defs attrs.Definitions, row T) interface{}
}

templ (c *funcColumn[T]) Header() {
	{{ assert.False(c.header == nil, "Column header is nil") }}
    { c.header(ctx) }
}

templ (c *funcColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	@getComponent(r, defs, row, c.data(r, defs, row))
}

func FuncColumn[T attrs.Definer](header func(ctx context.Context) string, data func(r *http.Request, defs attrs.Definitions, row T) interface{}) ListColumn[T] {
	return &funcColumn[T]{header, data}
}

type fieldColumn[T attrs.Definer] struct {
	header    func(ctx context.Context) string
	fieldName string
}

templ (c *fieldColumn[T]) Header() {
	{{ assert.False(c.header == nil, "Column header is nil") }}
    { c.header(ctx) }
}

func (c *fieldColumn[T]) data(r *http.Request, defs attrs.Definitions, _ T) interface{} {
	var field, ok = defs.Field(c.fieldName)

	assert.False(
		!ok,
		"Field %q does not exist", c.fieldName,
	)

	if field == nil {
		return nil
	}

	var d = field.GetValue()
	if attrs.IsZero(d) {
		return field.GetDefault()
	}

	switch f := d.(type) {
		case time.Time:
			return trans.Time(r.Context(), f, trans.LONG_TIME_FORMAT)
		case drivers.DateTime:
			return trans.Time(r.Context(), time.Time(f), trans.LONG_TIME_FORMAT)
		case drivers.LocalTime:
			return trans.Time(r.Context(), time.Time(f), trans.SHORT_TIME_FORMAT)
		case drivers.Timestamp:
			return trans.Time(r.Context(), time.Time(f), trans.SHORT_TIME_FORMAT)
	}

	return d
}

templ (c *fieldColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	@getComponent(r, defs, row, c.data(r, defs, row))
}

func FieldColumn[T attrs.Definer](header func(ctx context.Context) string, fieldName string) ListColumn[T] {
	return &fieldColumn[T]{header, fieldName}
}

type titleFieldColumn[T attrs.Definer] struct {
	wrapped ListColumn[T]
	getURL  func(r *http.Request, defs attrs.Definitions, row T) string
}

func (c *titleFieldColumn[T]) Media() media.Media {
	if m, ok := c.wrapped.(media.MediaDefiner); ok {
		return m.Media()
	}
	return nil
}

templ (c *titleFieldColumn[T]) Header() {
	<div class="list-title">
		@c.wrapped.Header()
	</div>
}

templ (c *titleFieldColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var url = templ.SafeURL(c.getURL(r, defs, row))}}
	<div class="list-title">
		if url == "" {
			@c.wrapped.Component(r, defs, row)
		} else {
			<a href={ url }>
				@c.wrapped.Component(r, defs, row)
			</a>
		}
	</div>
}

func TitleFieldColumn[T attrs.Definer](wraps ListColumn[T], getURL func(r *http.Request, defs attrs.Definitions, row T) string) ListColumn[T] {
	return &titleFieldColumn[T]{
		wrapped: wraps,
		getURL:  getURL,
	}
}

type htmlColumn[T attrs.Definer] struct {
	fieldColumn[T]
	getHTML func(r *http.Request, defs attrs.Definitions, row T) template.HTML
}

templ (c *htmlColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var html = c.getHTML(r, defs, row) }}
	@templ.Raw(html)
}

func HTMLColumn[T attrs.Definer](header func(ctx context.Context) string, getHTML func(r *http.Request, defs attrs.Definitions, row T) template.HTML) ListColumn[T] {
	return &htmlColumn[T]{
		fieldColumn: fieldColumn[T]{header: header},
		getHTML:    getHTML,
	}
}

type linkColumn[T attrs.Definer] struct {
	fieldColumn[T]
	getURL func(r *http.Request, defs attrs.Definitions, row T) string
}

templ (c *linkColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var url = templ.SafeURL(c.getURL(r, defs, row))}}
	if url == "" {
		@c.fieldColumn.Component(r, defs, row)
	} else {
		<a href={ url }>
			@c.fieldColumn.Component(r, defs, row)
		</a>
	}
}

func LinkColumn[T attrs.Definer](header func(ctx context.Context) string, fieldName string, getURL func(r *http.Request, defs attrs.Definitions, row T) string) ListColumn[T] {
	return &linkColumn[T]{
		fieldColumn: fieldColumn[T]{header, fieldName},
		getURL:     getURL,
	}
}

type rowSelectColumn[T attrs.Definer] struct {
	formName      string
	isChecked     func(r *http.Request, defs attrs.Definitions, row T) bool
	inputAttrs    map[string]any
	hasPermission func(r *http.Request, defs attrs.Definitions, row T) bool
	ListColumn[T]
}

func (c *rowSelectColumn[T]) checked(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.isChecked != nil {
		return c.isChecked(r, defs, row)
	}

	return false
}

func (c *rowSelectColumn[T]) permitted(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.hasPermission != nil {
		return c.hasPermission(r, defs, row)
	}

	return true
}

func (c *rowSelectColumn[T]) Media() media.Media {
	if m, ok := c.ListColumn.(media.MediaDefiner); ok {
		return m.Media()
	}
	return nil
}

templ (c *rowSelectColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	if !AllowListRowSelect(r.Context()) || !c.permitted(r, defs, row) {
		@c.ListColumn.Component(r, defs, row)
		{{ return }}
	}
	<div class="list-checkbox-wrapper">
		<div class="list-checkbox">
			<input { c.inputAttrs... } type="checkbox" class="list-checkbox__input" name={ c.formName } value={ attrs.ToString(attrs.PrimaryKey(row)) } checked?={ c.checked(r, defs, row) } />
		</div>
		<div class="list-checkbox__column">
			@c.ListColumn.Component(r, defs, row)
		</div>
	</div>
}

type BoundBoolFunc[T attrs.Definer] = func(r *http.Request, defs attrs.Definitions, row T) bool

func RowSelectColumn[T attrs.Definer](formName string, isChecked, hasPermission BoundBoolFunc[T], wraps ListColumn[T], attrs map[string]any) ListColumn[T] {
	return &rowSelectColumn[T]{
		formName:      formName,
		isChecked: isChecked,
		hasPermission: hasPermission,
		ListColumn: wraps,
		inputAttrs:  attrs,
	}
}

type fieldCheckbox[T attrs.Definer] struct {
	fieldColumn[T]
	inputAttrs    map[string]any
	hasPermission BoundBoolFunc[T]
}

func FieldCheckbox[T attrs.Definer](header func(ctx context.Context) string, fieldName string, hasPermission BoundBoolFunc[T]) ListColumn[T] {
	return &fieldCheckbox[T]{
		fieldColumn: fieldColumn[T]{header, fieldName},
		hasPermission: hasPermission,
	}
}

func (c *fieldCheckbox[T]) permitted(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.hasPermission != nil {
		return c.hasPermission(r, defs, row)
	}
	return true
}

templ (c *fieldCheckbox[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	if !AllowListEdit(r.Context()) || !c.permitted(r, defs, row) {
		@c.fieldColumn.Component(r, defs, row)
		{{ return }}
	}
	<div class="list-checkbox-wrapper">
		<div class="list-checkbox">
			<input { c.inputAttrs... } type="checkbox" class="list-checkbox__input" name={ c.fieldColumn.fieldName } value="1" checked?={ !django_reflect.IsZero(c.fieldColumn.data(r, defs, row)) } />
		</div>
	</div>
}

type listEditableColumn[T attrs.Definer] struct {
	header        func(ctx context.Context) string
	config       EditableColumnConfig
}

func (c *listEditableColumn[T]) permitted(r *http.Request, defs attrs.Definitions, row T) bool {
	if c.config.HasPermission != nil {
		return c.config.HasPermission(r, defs, row)
	}
	return true
}

func (c *listEditableColumn[T]) value(r *http.Request, defs attrs.Definitions, row T) interface{} {
	var field, ok = defs.Field(c.config.FieldName)
	assert.True(
		ok,
		"Field %q does not exist", c.config.FieldName,
	)

	var d = field.GetValue()
	if attrs.IsZero(d) {
		d = field.GetDefault()
	}

	if c.config.Widget != nil {
		d = c.config.Widget.ValueToForm(d)
	}

	return d
}

func (c *listEditableColumn[T]) FieldName() string {
	return c.config.FieldName
}

func (c *listEditableColumn[T]) FormField(r *http.Request, row T) fields.Field {
	var meta = attrs.GetModelMeta(row)
	var defs = meta.Definitions()
	var attrField, ok = defs.Field(c.config.FieldName)
	if !ok {
		assert.Fail("Field %q does not exist", c.config.FieldName)
		return nil
	}
	
	return attrField.FormField()
}

func (c *listEditableColumn[T]) Media(defs attrs.StaticDefinitions) media.Media {
	if c.config.Widget != nil {
		return c.config.Widget.Media()
	}

	var field, ok = defs.Field(c.config.FieldName)
	if !ok {
		assert.Fail("Field %q does not exist", c.config.FieldName)
		return media.NewMedia()
	}

	var formField = field.FormField()
	return formField.Widget().Media()
}

templ (c *listEditableColumn[T]) Header() {
	{{ assert.False(c.header == nil, "Column header is nil") }}
	{ c.header(ctx) }
}

templ (c *listEditableColumn[T]) EditableComponent(r *http.Request, defs attrs.Definitions, row T, form forms.Form, field *forms.BoundFormField) {
	if field == nil || !AllowListEdit(r.Context()) || !c.permitted(r, defs, row) {
		@getComponent(r, defs, row, c.value(r, defs, row))
		{{ return }}
	}
	<div class="list-editable">
		{{ field.FormValue = c.value(r, defs, row) }}
		@templ.Raw(string(field.Field()))
	</div>
}

templ (c *listEditableColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	@getComponent(r, defs, row, c.value(r, defs, row))
}

type EditableColumnConfig struct {
	FieldName     string
	Widget        widgets.Widget
	WidgetAttrs   map[string]string
	HasPermission BoundBoolFunc[attrs.Definer]
}

func EditableColumn[T attrs.Definer](header func(ctx context.Context) string, config EditableColumnConfig) ListColumn[T] {
	return &listEditableColumn[T]{
		header: header,
		config: config,
	}
}

func Column[T attrs.Definer](header func(ctx context.Context) string, getter any) ListColumn[T] {
	switch g := getter.(type) {
	case func(r *http.Request, defs attrs.Definitions, row T) interface{}:
		return &funcColumn[T]{header, g}
	case string:
		return &fieldColumn[T]{header, g}
	default:
		assert.Fail("Invalid column getter type")
		return nil
	}
}
