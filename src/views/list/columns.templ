package list

import (
	"context"
    "github.com/Nigel2392/go-django/src/core/attrs"
    "github.com/Nigel2392/go-django/src/core/assert"
	"html/template"
	"time"
	"net/http"
)

type booleanColumn[T attrs.Definer] struct {
	header func(ctx context.Context) string
	data   func(r *http.Request, defs attrs.Definitions, row T) bool
}

templ (c *booleanColumn[T]) Header() {
	{{ assert.False(c.header == nil, "Column header is nil") }}
	{ c.header(ctx) }
}

templ (c *booleanColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	if c.data(r, defs, row) {
		<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="list-check-yes" viewBox="0 0 16 16">
		 	<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>
		 	<path d="m10.97 4.97-.02.022-3.473 4.425-2.093-2.094a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05"/>
		</svg>
	} else {
		<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="list-check-no" viewBox="0 0 16 16">
		  	<path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/>
		  	<path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708"/>
		</svg>
	}
}

func BooleanColumn[T attrs.Definer](header func(ctx context.Context) string, data func(r *http.Request, defs attrs.Definitions, row T) bool) ListColumn[T] {
	return &booleanColumn[T]{header, data}
}

type funcColumn[T attrs.Definer] struct {
	header func(ctx context.Context) string
	data   func(r *http.Request, defs attrs.Definitions, row T) interface{}
}

templ (c *funcColumn[T]) Header() {
	{{ assert.False(c.header == nil, "Column header is nil") }}
    { c.header(ctx) }
}

templ (c *funcColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
    { attrs.ToString(
        c.data(r, defs, row),
    ) }
}

func FuncColumn[T attrs.Definer](header func(ctx context.Context) string, data func(r *http.Request, defs attrs.Definitions, row T) interface{}) ListColumn[T] {
	return &funcColumn[T]{header, data}
}

type fieldColumn[T attrs.Definer] struct {
	header    func(ctx context.Context) string
	fieldName string
}

templ (c *fieldColumn[T]) Header() {
	{{ assert.False(c.header == nil, "Column header is nil") }}
    { c.header(ctx) }
}

func (c *fieldColumn[T]) data(r *http.Request, defs attrs.Definitions, _ T) interface{} {
	var field, ok = defs.Field(c.fieldName)

	assert.False(
		!ok,
		"Field %q does not exist", c.fieldName,
	)

	if field == nil {
		return nil
	}

	var d = field.GetValue()
	if attrs.IsZero(d) {
		return field.GetDefault()
	}

	switch f := d.(type) {
		case time.Time:
			return f.Format("2006-01-02 15:04:05")
		default:
			return d
	}
}

templ (c *fieldColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
    { attrs.ToString(
        c.data(r, defs, row),
    ) }
}

func FieldColumn[T attrs.Definer](header func(ctx context.Context) string, fieldName string) ListColumn[T] {
	return &fieldColumn[T]{header, fieldName}
}

type titleFieldColumn[T attrs.Definer] struct {
	wrapped ListColumn[T]
	getURL  func(r *http.Request, defs attrs.Definitions, row T) string
}

templ (c *titleFieldColumn[T]) Header() {
	<div class="list-title">
		@c.wrapped.Header()
	</div>
}

templ (c *titleFieldColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var url = templ.SafeURL(c.getURL(r, defs, row))}}
	<div class="list-title">
		if url == "" {
			@c.wrapped.Component(r, defs, row)
		} else {
			<a href={ url }>
				@c.wrapped.Component(r, defs, row)
			</a>
		}
	</div>
}

func TitleFieldColumn[T attrs.Definer](wraps ListColumn[T], getURL func(r *http.Request, defs attrs.Definitions, row T) string) ListColumn[T] {
	return &titleFieldColumn[T]{
		wrapped: wraps,
		getURL:  getURL,
	}
}

type htmlColumn[T attrs.Definer] struct {
	fieldColumn[T]
	getHTML func(r *http.Request, defs attrs.Definitions, row T) template.HTML
}

templ (c *htmlColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var html = c.getHTML(r, defs, row) }}
	@templ.Raw(html)
}

func HTMLColumn[T attrs.Definer](header func(ctx context.Context) string, getHTML func(r *http.Request, defs attrs.Definitions, row T) template.HTML) ListColumn[T] {
	return &htmlColumn[T]{
		fieldColumn: fieldColumn[T]{header: header},
		getHTML:    getHTML,
	}
}

type linkColumn[T attrs.Definer] struct {
	fieldColumn[T]
	getURL func(r *http.Request, defs attrs.Definitions, row T) string
}

templ (c *linkColumn[T]) Component(r *http.Request, defs attrs.Definitions, row T) {
	{{ var url = templ.SafeURL(c.getURL(r, defs, row))}}
	if url == "" {
		@c.fieldColumn.Component(r, defs, row)
	} else {
		<a href={ url }>
			@c.fieldColumn.Component(r, defs, row)
		</a>
	}
}

func LinkColumn[T attrs.Definer](header func(ctx context.Context) string, fieldName string, getURL func(r *http.Request, defs attrs.Definitions, row T) string) ListColumn[T] {
	return &linkColumn[T]{
		fieldColumn: fieldColumn[T]{header, fieldName},
		getURL:     getURL,
	}
}

func Column[T attrs.Definer](header func(ctx context.Context) string, getter any) ListColumn[T] {
	switch g := getter.(type) {
	case func(r *http.Request, defs attrs.Definitions, row T) interface{}:
		return &funcColumn[T]{header, g}
	case string:
		return &fieldColumn[T]{header, g}
	default:
		assert.Fail("Invalid column getter type")
		return nil
	}
}
