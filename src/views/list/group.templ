package list

import (
	"github.com/Nigel2392/go-django/src/core/attrs"
	"github.com/Nigel2392/go-django/src/forms"
	"net/http"
	"github.com/Nigel2392/go-django/src/forms"
	"github.com/Nigel2392/go-django/src/core/except"
	"maps"
	"github.com/Nigel2392/go-django/src/forms/modelforms"
)

type ListColumnGroup[T attrs.Definer] struct {
	Definitions attrs.Definitions
	Columns    []ListColumn[T]
	Instance   T
	Attrs      func(r *http.Request, definitions attrs.Definitions, instance T) map[string]any
}

func NewColumnGroup[T attrs.Definer](r *http.Request, instance T, columns []ListColumn[T]) *ListColumnGroup[T] {
	return &ListColumnGroup[T]{
		Definitions: instance.FieldDefs(),
		Columns:    columns,
		Instance:   instance,
	}
}

func (c *ListColumnGroup[T]) Row() T {
	return c.Instance
}

func (c *ListColumnGroup[T]) AddColumn(column ListColumn[T]) {
	c.Columns = append(c.Columns, column)
}

func (c *ListColumnGroup[T]) Form(r *http.Request, opts ...func(forms.Form)) forms.Form {
	var columns = make([]ListEditableColumn[T], 0)
	for _, column := range c.Columns {
		if def, ok := column.(ListEditableColumn[T]); ok {
			columns = append(columns, def)
		}
	}

	if len(columns) == 0 {
		return nil
	}

	var form = modelforms.NewBaseModelForm(r.Context(), c.Instance, opts...)
	var fieldsAdded bool
	for _, column := range columns {
		var (
			fieldName = column.FieldName()
			field     = column.FormField(r, c.Instance)
		)

		if fieldName == "" || field == nil {
			continue
		}

		form.AddField(fieldName, field)
		fieldsAdded = true
	}

	if !fieldsAdded {
		return nil
	}

	return form
}

func (c *ListColumnGroup[T]) GetAttrs(r *http.Request, definitions attrs.Definitions, instance T) map[string]any {
	var attrs map[string]any
	if c.Attrs != nil {
		attrs = c.Attrs(r, definitions, instance)
	}
	if attrs == nil {
		attrs = make(map[string]any)
	}
	return attrs
}

templ (c *ListColumnGroup[T]) RenderColumns(r *http.Request, form *ListForm[T]) {
	{{ var colCount = len(c.Columns) }}
	for colIndex, column := range c.Columns {
		{{ var attrs = c.GetAttrs(r, c.Definitions, c.Instance) }}
		{{ maps.Copy(attrs, column.Attributes(r, c.Definitions, c.Instance, colIndex, colCount)) }}

		if form == nil || !AllowListEdit(ctx) {
			// If the user is not allowed to edit the list, render the column as read-only
			<td class="list-column" { templ.Attributes(attrs)... }>
				@column.Component(r, c.Definitions, c.Instance)
			</td>
			{{ continue }}
		}

		<td class="list-column" { templ.Attributes(attrs)... }>
			switch col := column.(type) {
			case ListEditableColumn[T]:
				{{ var fieldName = col.FieldName() }}
				if fieldName == "" || col.FormField(r, c.Instance) == nil {
					@col.Component(r, c.Definitions, c.Instance)
					{{ continue }}
				}

				{{ var rowForm = form.ForInstance(c.Instance) }}
				{{ var boundFields = rowForm.BoundFields() }}
				{{ var field, ok = boundFields.Get(fieldName) }}
				if !ok {
					{{ return except.Fail(http.StatusInternalServerError, "could not find field %q in bound fields", col.FieldName()) }}
				}

				@col.EditableComponent(r, c.Definitions, c.Instance, rowForm, field.(*forms.BoundFormField))
			default:
				@col.Component(r, c.Definitions, c.Instance)
			}
		</td>
	}
}

templ (c *ListColumnGroup[T]) Component(r *http.Request, form *ListForm[T]) {
	<tr class="column-group">
		@c.RenderColumns(r, form)
	</tr>
}
