package translations

import (
	"flag"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"time"

	django "github.com/Nigel2392/go-django/src"
	"github.com/Nigel2392/go-django/src/core/command"
	"github.com/Nigel2392/go-django/src/core/command/flags"
	"github.com/Nigel2392/go-django/src/core/logger"
	"github.com/Nigel2392/go-django/src/core/trans"
	"github.com/elliotchance/orderedmap/v2"
	"github.com/urfave/cli/v2"
	"gopkg.in/yaml.v3"
)

type translationsCommandContext struct {
	dir  flags.List
	locs flags.List
	file string
}

var makeTranslationsCommand = &command.Cmd[translationsCommandContext]{
	ID:   "make-translations",
	Desc: "Search for translation strings in the project files",
	FlagFunc: func(m command.Manager, stored *translationsCommandContext, f *flag.FlagSet) error {
		stored.dir = flags.NewList(django.ConfigGet(django.Global.Settings, APPVAR_TRANSLATIONS_DIR, []string{})...)
		stored.locs = flags.NewList(django.ConfigGet[[]string](django.Global.Settings, APPVAR_TRANSLATIONS_LOCALES)...)
		stored.file = django.ConfigGet(django.Global.Settings, APPVAR_TRANSLATIONS_FILE, translationsFile)

		f.Var(&stored.dir, "dir", "The directory to search for translation strings")
		f.Var(&stored.locs, "locales", "Generate the following locales for the translation strings")
		f.StringVar(&stored.file, "file", translationsFile, "Output the found translations to a file (default is translations.yml)")

		return nil
	},
	Execute: func(m command.Manager, stored translationsCommandContext, args []string) (err error) {

		if stored.dir.Len() == 0 {
			var projectPath, err = os.Getwd()
			if err != nil {
				return err
			}

			stored.dir = flags.NewList(projectPath)
		}

		var matches = make([]Translation, 0)
		var dirFsys []fs.FS
		for _, dir := range stored.dir.List() {
			dirFsys = append(dirFsys, os.DirFS(filepath.ToSlash(dir)))
		}

		var locales = stored.locs
		if locales.Len() == 0 {
			locales = flags.NewList()
		}

		for _, fsys := range append(dirFsys, translatorApp.filesystems...) {
			for _, finder := range translatorApp.finders {
				var found, err = finder.Find(fsys)
				if err != nil {
					return cli.Exit(
						"Error finding translations: "+err.Error(), 1,
					)
				}

				matches = append(matches, found...)
			}
		}

		if len(matches) == 0 {
			logger.Info("No translation strings found.")
			return nil
		}

		var outputFile = stored.file
		if outputFile == "" {
			outputFile = translationsFile
		}

		// Encode the new (or old header) and matches to YAML
		// Write each Translation as a separate YAML document
		// This can be done by delimiting each Translation with "---"
		if translatorApp.translationHeader == nil || translatorApp.translationHeader.hdr == nil {
			translatorApp.translationHeader = newTranslationHeader(&FileTranslationsHeader{
				Comment:     "Translations file generated by godjango",
				Generator:   "godjango",
				Created:     time.Now(),
				Translators: []string{},
				Locales:     orderedmap.NewOrderedMap[string, TranslationHeaderLocale](),
			})
		}

		if len(locales.List()) > 0 {
			for _, locale := range locales.List() {

				var rule, ok = pluralRules[locale]
				if !ok {
					rule = pluralRule{
						l:   2,
						r:   "(n != 1) ? 1 : 0",
						stf: trans.DEFAULT_TIME_FORMAT,
						ltf: trans.DEFAULT_TIME_FORMAT,
					}
				}

				if loc, ok := translatorApp.translationHeader.hdr.Locales.Get(locale); ok {
					if loc.LongTimeFormat == "" {
						loc.LongTimeFormat = rule.ltf
					}

					if loc.ShortTimeFormat == "" {
						loc.ShortTimeFormat = rule.stf
					}

					if loc.NumPluralForms == 0 {
						loc.NumPluralForms = rule.l
					}

					if loc.PluralRule == "" {
						loc.PluralRule = rule.r
					}

					translatorApp.translationHeader.hdr.Locales.Set(locale, loc)
					continue // Locale already exists
				}

				translatorApp.translationHeader.hdr.Locales.Set(locale, TranslationHeaderLocale{
					NumPluralForms:  rule.l,
					PluralRule:      rule.r,
					ShortTimeFormat: rule.stf,
					LongTimeFormat:  rule.ltf,
				})
			}
		}

		logger.Infof("Writing translations to: %s", outputFile)

		var oldMatchMap = make(map[string]Translation)
		for _, m := range translatorApp.translationMatches {
			var key = m.Text
			if m.Plural != "" {
				key = getHashForPluralTexts(m.Text, m.Plural)
			}
			if _, ok := oldMatchMap[key]; !ok {
				oldMatchMap[key] = m
			}
		}

		sortMatches(matches)

		var newMatches = make([]*Translation, 0, len(matches))
		var foundMatches = make(map[string]*Translation)
		for _, m := range matches {

			// Check if we already have this Translation in the old matches
			//
			// If so, we should preserve its locales (and thus also its translations)
			var key = m.Text
			if m.Plural != "" {
				key = getHashForPluralTexts(m.Text, m.Plural)
			}
			if oldItem, ok := oldMatchMap[key]; ok {
				m.Locales = oldItem.Locales // Preserve locales
				if oldItem.Comment != m.Comment && m.Comment == "" {
					m.Comment = oldItem.Comment
				}
			}

			// Initialize locales if not already set up
			if m.Locales == nil {
				m.Locales = orderedmap.NewOrderedMap[string, []string]()
			}

			// Ensure all requested locales are present
			// If a locale is not found, it will be added with an empty string value
			for _, locale := range locales.List() {
				if _, ok := m.Locales.Get(locale); !ok {
					// m.Locales.Set(locale, []string{""})
					var headerLocale, ok = translatorApp.translationHeader.hdr.Locales.Get(locale)
					if !ok || m.Plural == "" {
						m.Locales.Set(locale, []string{""})
					} else {
						m.Locales.Set(locale, make([]string, headerLocale.NumPluralForms))
					}
				}
			}

			// If we already have a Translation with the same text, we can skip adding it again
			if foundMatch, ok := foundMatches[key]; ok {

				foundMatch.Paths = append(foundMatch.Paths, fmt.Sprintf(
					"%s\t%s:%d:%d", m.Comment, m.Path, m.Line, m.Col,
				))

				if m.Locales == nil || m.Locales.Len() == 0 {
					continue // Skip matches without locales
				}

				for head := m.Locales.Front(); head != nil; head = head.Next() {

					if len(head.Value) == 0 || head.Value[0] == "" {
						continue // Skip empty translations
					}

					foundMatch.Locales.Set(head.Key, head.Value)
				}
				continue
			}

			newMatches = append(newMatches, &m)
			foundMatches[key] = &m
		}

		file, err := os.OpenFile(
			outputFile,
			os.O_CREATE|os.O_RDWR, 0644,
		)
		if err != nil {
			return cli.Exit(
				"Error creating output file: "+err.Error(), 1,
			)
		}
		defer file.Close()

		// Clear the file content
		file.Truncate(0)

		if translatorApp.translationHeader == nil {
			return cli.Exit(
				"Error: translation header is nil", 1,
			)
		}

		var encoder = yaml.NewEncoder(file)
		encoder.SetIndent(2)
		if err := encoder.Encode(translatorApp.translationHeader.hdr); err != nil {
			return cli.Exit(
				"Error encoding translation header: "+err.Error(), 1,
			)
		}

		if err := encoder.Close(); err != nil {
			return cli.Exit(
				"Error closing encoder: "+err.Error(), 1,
			)
		}

		file.WriteString("\n") // Ensure header ends with a newline

		for _, m := range newMatches {

			file.WriteString("---\n\n") // YAML document separator

			var locales = m.Locales
			if locales != nil {
				var keys = locales.Keys()

				slices.Sort(keys) // Sort keys to ensure consistent order

				var newLocales = orderedmap.NewOrderedMap[trans.Locale, []trans.Translation]()
				for _, key := range keys {
					if value, ok := locales.Get(key); ok {
						newLocales.Set(key, value)
					}
				}

				m.Locales = newLocales
			}

			var encoder = yaml.NewEncoder(file)
			encoder.SetIndent(2)
			if err := encoder.Encode(m); err != nil {
				return cli.Exit(
					"Error encoding new translations: "+err.Error(), 1,
				)
			}

			if err := encoder.Close(); err != nil {
				return cli.Exit(
					"Error closing encoder: "+err.Error(), 1,
				)
			}

			file.WriteString("\n") // Ensure each Translation is on a new line
		}

		// Success!
		logger.Infof("Translations written to %s successfully.", outputFile)
		return nil
	},
}

func readTranslationsYAML(rd io.Reader, header *FileTranslationsHeader, slice []Translation) ([]Translation, error) {
	var dec = yaml.NewDecoder(rd)
	dec.KnownFields(true)

	if err := dec.Decode(header); err != nil {
		if err == io.EOF {
			return slice, nil // No matches found
		}
		return nil, fmt.Errorf(
			"error decoding translations header: %w", err,
		)
	}

	for {
		var m Translation
		if err := dec.Decode(&m); err != nil {
			if err == io.EOF {
				break
			}
			return nil, fmt.Errorf(
				"eror decoding Translation: %w", err,
			)
		}
		slice = append(slice, m)
	}

	return slice, nil
}

func comparePaths(a, b Translation) int {
	if a.Path != b.Path {
		return strings.Compare(a.Path, b.Path)
	}
	if a.Line != b.Line {
		return a.Line - b.Line
	}
	if a.Col != b.Col {
		return a.Col - b.Col
	}
	return 0
}

func matchCompare(a, b Translation) int {
	// 3. Text: non-empty before empty, alpha
	if a.Text == "" && b.Text == "" {
		return 0
	}

	if a.Text == "" {
		return 1 // a is empty, b not: b first
	}

	if b.Text == "" {
		return -1 // b is empty, a not: a first
	}

	return 0
}

func sortMatches(matches []Translation) {
	slices.SortStableFunc(matches, comparePaths)
	slices.SortStableFunc(matches, matchCompare)
	slices.SortStableFunc(matches, func(a, b Translation) int {
		return b.Preference - a.Preference // higher first
	})
}

func mapFromTranslations(matches []Translation) map[trans.Locale]map[trans.Untranslated][]trans.Translation {
	result := make(map[trans.Locale]map[trans.Untranslated][]trans.Translation)

	for _, m := range matches {
		if m.Locales == nil || m.Locales.Len() == 0 {
			continue // Skip matches without locales
		}

		for head := m.Locales.Front(); head != nil; head = head.Next() {
			if len(head.Value) == 0 || head.Value[0] == "" {
				continue // Skip empty translations
			}

			if _, ok := result[head.Key]; !ok {
				result[head.Key] = make(map[trans.Untranslated][]trans.Translation)
			}

			var key = m.Text
			if m.Plural != "" {
				key = getHashForPluralTexts(m.Text, m.Plural)
			}

			translations, ok := result[head.Key]
			if !ok {
				translations = make(map[trans.Untranslated][]trans.Translation)
				result[head.Key] = translations
			}

			translations[key] = head.Value
		}
	}

	return result
}
