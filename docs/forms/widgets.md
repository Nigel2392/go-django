# Widgets Package Documentation

**Note**: This documentation page was (in part) generated by ChatGPT and has been fully reviewed by [Nigel2392](github.com/Nigel2392).

The `widgets` package provides a set of reusable HTML form components that are used to capture user input. These widgets are pre-defined, customizable, and can be extended to meet specific form needs. They are primarily used alongside form fields to render form inputs, but can also be used independently.

## Overview

Widgets are visual components that represent form fields. They handle the rendering of inputs like text boxes, checkboxes, radio buttons, and more. Each widget can be customized using HTML attributes provided as a map of key-value pairs (`attrs`). Additionally, widgets offer flexibility by supporting custom behaviors and validation logic.

## Widget Creation

The `widgets` package includes several factory functions to create commonly used form input widgets. Each widget is constructed using attributes and, where necessary, additional parameters such as validation functions or special configuration. Below are the available widgets and how they are created.

### Predefined Widgets

- **`NewTextInput(attrs map[string]string) Widget`**: Creates a text input widget.
- **`NewTextarea(attrs map[string]string) Widget`**: Creates a textarea widget.
- **`NewEmailInput(attrs map[string]string) Widget`**: Creates an email input widget.
- **`NewPasswordInput(attrs map[string]string) Widget`**: Creates a password input widget.
- **`NewHiddenInput(attrs map[string]string) Widget`**: Creates a hidden input widget.
- **`NewNumberInput[T NumberType](attrs map[string]string) Widget`**: Creates a number input widget, supporting numeric types like `int`, `float`.
- **`NewBooleanInput(attrs map[string]string) Widget`**: Creates a boolean input widget, typically rendered as a checkbox.
- **`NewDateInput(attrs map[string]string, t DateWidgetType) Widget`**: Creates a date input widget. `DateWidgetType` can specify if it's a date or datetime-local input.
- **`NewFileInput(attrs map[string]string, validators ...func(filename string, file io.ReadSeeker) error) Widget`**: Creates a file input widget with optional validators to validate the uploaded file.

### Options Widgets

- **`NewCheckboxInput(attrs map[string]string, choices func() []Option) Widget`**: Creates a checkbox input widget with multiple choices.
- **`NewRadioInput(attrs map[string]string, choices func() []Option) Widget`**: Creates a radio input widget with multiple choices.
- **`NewSelectInput(attrs map[string]string, choices func() []Option) Widget`**: Creates a select (dropdown) input widget with multiple choices.

## Widget Interface

Each widget implements the `Widget` interface, which provides methods for rendering, handling attributes, and interacting with form data. Below are the methods available in this interface:

### Widget Methods

- **`IsHidden() bool`**: Determines if the widget is hidden.
- **`Hide(hidden bool)`**: Hides or shows the widget based on the boolean flag.
- **`Type() string`**: Returns the widget's HTML type (e.g., `text`, `checkbox`, `radio`, etc.).
- **`SetAttrs(attrs map[string]string)`**: Sets the HTML attributes for the widget.
- **`IdForLabel(id string) string`**: Generates the `id` attribute for the widget’s label.
- **`GetContextData(id, name string, value interface{}, attrs map[string]string) ctx.Context`**: Provides context data used to render the widget, including its `id`, `name`, value, and attributes.
- **`Render(w io.Writer, id, name string, value interface{}, attrs map[string]string) error`**: Renders the widget to the provided `io.Writer`.
- **`RenderWithErrors(w io.Writer, id, name string, value interface{}, errors []error, attrs map[string]string) error`**: Renders the widget along with any validation errors.

### Form Data Handling

Widgets handle form data conversion and extraction. The following methods are responsible for interacting with form data:

- **`ValueToGo(value interface{}) (interface{}, error)`**: Converts the form's string value into the appropriate Go type.
- **`ValueToForm(value interface{}) interface{}`**: Converts a Go value back into its string form for rendering in the form.
- **`ValueOmittedFromData(data url.Values, files map[string][]filesystem.FileHeader, name string) bool`**: Checks whether the form data omitted a value for this widget.
- **`ValueFromDataDict(data url.Values, files map[string][]filesystem.FileHeader, name string) (interface{}, []error)`**: Retrieves the value from the form data and handles any associated errors.

## Example: Widget Usage

Here are some examples of how to create and use widgets in your Go application:

```go
// Creating a text input with placeholder
textWidget := widgets.NewTextInput(map[string]string{
    "placeholder": "Enter your text here",
})

// Creating a password input with a custom class
passwordWidget := widgets.NewPasswordInput(map[string]string{
    "class": "secure-input",
})

// Rendering a widget with errors
err := passwordWidget.RenderWithErrors(writer, "password", "password", nil, []error{errors.New("Invalid password")}, map[string]string{})
if err != nil {
    log.Fatal(err)
}
```

Widgets are typically used with form fields to generate form elements that accept user input. The `fields` package offers a collection of form fields that work in tandem with these widgets to render complete form elements.

## Options Widgets

`OptionsWidget`-based widgets (e.g., select, checkbox, radio) handle multiple-choice inputs. Options are defined using the `Option` interface, which consists of `Label()` and `Value()` methods. You can define options dynamically or statically.

### Example for Checkbox Input

```go
choices := func() []widgets.Option {
    return []widgets.Option{
        widgets.NewOption("option1", "Label 1", "1"),
        widgets.NewOption("option2", "Label 2", "2"),
    }
}
checkboxWidget := widgets.NewCheckboxInput(map[string]string{"class": "checkbox-class"}, choices)
```

### Handling Blank Options

For select widgets, a blank option can be included by setting `IncludeBlank` to `true`. You can customize the label for the blank option using `BlankLabel`.

## Media Files

Widgets that depend on external media (like JavaScript or CSS) implement the `MediaDefiner` interface. This interface manages the inclusion of these media files, ensuring proper rendering and interaction of the widget on the client side.

## Customizing Widgets

You can easily customize widgets by setting the attributes (`attrs`) or by extending the widget interface to create entirely new widgets.

### Example: Custom Widget

Here’s an example of how to create a custom widget by implementing the `Widget` interface:

```go
type MyCustomWidget struct {
    // custom fields
}

func (w *MyCustomWidget) IsHidden() bool {
    return false
}

func (w *MyCustomWidget) Hide(hidden bool) {
    // implementation
}

func (w *MyCustomWidget) Type() string {
    return "custom"
}

// Implement other required methods...
```
