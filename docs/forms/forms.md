# Forms Package Documentation

**Note**: This documentation page was (in part) generated by ChatGPT and has been fully reviewed by [Nigel2392](github.com/Nigel2392).

The forms package is the central piece for building and processing HTML forms. It handles everything from collecting user input and validating data to rendering the form along with any error messages. It works in tandem with the already-documented packages—**fields**, **widgets**, and **media**—to provide a complete, flexible form-handling solution.

---

## Core Interfaces

### Cleaner  

A simple interface for cleaning form input values.

```go
type Cleaner interface {
    Clean(value interface{}) (interface{}, error)
}
```

*Purpose:*  
After data is submitted, cleaning transforms raw input into a Go value (for example, trimming strings or parsing dates).

---

### Validator  

An interface for validating a field's value.

```go
type Validator interface {
    Validate(value interface{}) []error
}
```

*Purpose:*  
This lets you check whether a value meets certain conditions (such as a required field or proper format).

---

### BoundField  

Represents a single form field bound to an instance of a form. A bound field carries along the field’s widget, label, help text, and any errors.

```go
type BoundField interface {
    ID() string
    Name() string
    Widget() widgets.Widget
    Input() fields.Field
    Label() template.HTML
    HelpText() template.HTML
    Field() template.HTML
    HTML() template.HTML
    Attrs() map[string]string
    Value() interface{}
    Errors() []error
}
```

*Purpose:*  
A bound field is what gets rendered in a template. It holds both the original field and the current value (plus any errors from validation).

---

### FormRenderer  

This interface defines how a form is rendered to HTML.

```go
type FormRenderer interface {
    AsP() template.HTML
    AsUL() template.HTML
    Media() media.Media
}
```

*Purpose:*  
It provides helper methods to output the form as paragraphs or as an unordered list, and to include any required CSS/JS (via media).

---

### ErrorAdder and FieldError  

These interfaces let you add and track errors within a form.

```go
type ErrorAdder interface {
    AddFormError(errorList ...error)
    AddError(name string, errorList ...error)
}

type FieldError interface {
    Field() string
    Errors() []error
}
```

*Purpose:*  
They help in collecting error messages, both general form errors and field-specific ones, so you can display them to the user.

---

## The Form Interface

The main interface of the forms package is the **Form** interface. It builds on the renderer and error handling ideas to give you a full lifecycle for form processing.

```go
type Form interface {
    FormRenderer

    Prefix() string
    SetPrefix(prefix string)
    SetInitial(initial map[string]interface{})
    SetValidators(validators ...func(Form) []error)
    Ordering([]string)
    FieldOrder() []string

    Field(name string) (fields.Field, bool)
    Widget(name string) (widgets.Widget, bool)
    Fields() []fields.Field
    Widgets() []widgets.Widget
    AddField(name string, field fields.Field)
    AddWidget(name string, widget widgets.Widget)
    DeleteField(name string) bool
    BoundForm() BoundForm
    BoundFields() *orderedmap.OrderedMap[string, BoundField]
    BoundErrors() *orderedmap.OrderedMap[string, []error]
    ErrorList() []error

    WithData(data url.Values, files map[string][]filesystem.FileHeader, r *http.Request) Form
    InitialData() map[string]interface{}
    CleanedData() map[string]interface{}

    FullClean()
    Validate()
    HasChanged() bool
    IsValid() bool

    OnValid(...func(Form))
    OnInvalid(...func(Form))
    OnFinalize(...func(Form))
}
```

*Key Functions:*

- **Prefix & Initial Data:**  
  You can set a prefix to avoid naming conflicts and provide initial values to populate the form.

- **Field Management:**  
  Methods like `Field()`, `AddField()`, and `DeleteField()` let you inspect and modify the form structure.

- **Validation:**  
  After submitting data, you call `FullClean()` and `Validate()` to process and check the form values. Methods like `IsValid()` and `ErrorList()` tell you if the data is good.

- **Callbacks:**  
  The `OnValid`, `OnInvalid`, and `OnFinalize` methods allow you to register functions that run when the form is valid, invalid, or at the end of processing.

- **Rendering:**  
  Through the `FormRenderer` interface, you can output the form as HTML and include any required media files.

---

## SaveableForm

Sometimes you need your form to do more than just validate data—you want to save it too. The **SaveableForm** interface extends **Form** with a `Save()` method:

```go
type SaveableForm interface {
    Form
    Save() (map[string]interface{}, error)
}
```

*Purpose:*  
After validating the form data, you can save it (for example, inserting it into a database). The `Save()` method returns the saved data or any errors that occurred.

---

## How to Use the Forms Package

Typically, you would use the forms package in combination with the fields, widgets, and media packages to build your forms. Here’s a simplified example that shows the overall flow:

1. **Initialize the Form:**

   ```go
   var form = forms.Initialize(
       forms.NewBaseForm(),
       forms.WithRequestData("POST", r),
       forms.WithFields(
           fields.EmailField(
               fields.Label("Email"),
               fields.HelpText("Enter your email"),
               fields.Name("email"),
               fields.Required(true),
               fields.MinLength(5),
               fields.MaxLength(250),
               fields.Widget(widgets.NewEmailInput(nil)),
           ),
           fields.CharField(
               fields.Label("Name"),
               fields.HelpText("Enter your name"),
               fields.Name("name"),
               fields.Required(true),
               fields.Regex(`^[a-zA-Z]+$`),
               fields.MinLength(2),
               fields.MaxLength(50),
           ),
           // ... add other fields as needed
       ),
       forms.OnValid(func(f forms.Form) {
           fmt.Println("Form is valid")
           data := f.CleanedData()
           for k, v := range data {
               fmt.Printf("%T, %s: %v\n", v, k, v)
           }
       }),
       forms.OnInvalid(func(f forms.Form) {
           fmt.Println("Form is invalid:", f.BoundErrors())
       }),
       forms.OnFinalize(func(f forms.Form) {
           fmt.Println("Finalizing form:", f.BoundErrors())
       }),
   )
   ```

2. **Render the Form in a Template:**

   In your HTML template, you might include the media and iterate over the form fields:

   ```html
   <div class="form-media">
       {{ range $File := (.Get "Form").Media.JS }}
           {{ $File }}
       {{ end }}
       {{ range $File := (.Get "Form").Media.CSS }}
           {{ $File }}
       {{ end }}
   </div>

   <form method="post">
       <input type="hidden" name="csrf_token" value="{{ .CsrfToken }}">
       {{ $errorList := (.Get "Form").ErrorList }}
       {{ if (gt (len $errorList) 0) }}
           <ul class="error-list">
               {{ range $Error := $errorList }}
                   <li class="error"><p>{{ $Error }}</p></li>
               {{ end }}
           </ul>
       {{ end }}

       {{ range $Field := (.Get "Form").Fields }}
           <div class="form-field-wrapper">
               <div class="form-field">
                   {{ $Field.Label }}
                   {{ if (gt (len $Field.Errors) 0) }}
                       <ul class="error-list">
                           {{ range $Error := $Field.Errors }}
                               <li class="error"><p>{{ $Field.Label }}: {{ $Error }}</p></li>
                           {{ end }}
                       </ul>
                   {{ end }}

                   {{ if (ne $Field.HelpText "") }}
                       <p class="help-text">{{ $Field.HelpText }}</p>
                   {{ end }}

                   {{ $Field.Field }}
               </div>
           </div>
       {{ end }}

       <input type="submit" value="Submit">
   </form>
   ```

3. **Process Form Data on Submission:**

   When a POST request is received, the form reads the request data, validates it, and makes the cleaned data available for use (for example, saving to a database).

   ```go
   if r.Method == "POST" && form.IsValid() {
       validFormData := form.CleanedData()
       // Process or save the cleaned data...
   }
   ```

4. **Integrate with Models (Optional):**

   If you’re using the modelforms package, you can bind a model to the form to load data and update the model after validation.

   ```go
   modelForm := modelforms.NewBaseModelForm(existingModel)
   modelForm.Load() // load data from the model into the form
   // after validation...
   if err := modelForm.Save(); err != nil {
       // handle error
   }
   ```

---

The forms package is designed to work seamlessly with the fields, widgets, and media packages to build fully featured forms that can be easily rendered in HTML templates and integrated with your Go application's models.

As seen, the media required for the fields to work is provided by the form itself, making it easy to include CSS and JS files in your templates. The form lifecycle, from initialization to validation and rendering, is well-defined, allowing you to build robust forms with ease.
