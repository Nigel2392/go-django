# Paginator Usage Documentation

**Note**: This documentation page was (in part) generated by ChatGPT and has been fully reviewed by [Nigel2392](github.com/Nigel2392).

## Overview

The paginator provides an easy way to paginate through a large set of data, breaking it into manageable pages. It requires you to implement functions for retrieving individual items, fetching a range of items, and counting the total number of items. The paginator is generic and can be used with any type.

## Example Usage

Hereâ€™s an example of how to use the paginator:

```go
var ctx = core.Context(r)

var paginator = pagination.Paginator[MyObject]{
    GetObject: func(obj MyObject) MyObject {
        // This function is called for each item in the returned list.
        // You can use it to modify or wrap each item if needed.
        return obj
    },
    GetObjects: func(limit, offset int) ([]MyObject, error) {
        // This function fetches a slice of MyObject items based on the given limit and offset.
        return getMyObjects(limit, offset)
    },
    GetCount: func() (int, error) {
        // This function returns the total number of items available.
        return getMyObjectTotalCount()
    },
    Amount: 15, // Number of items per page
}

var pageNum = pagination.GetPageNum(r.URL.Query().Get("page"))

var page, err = paginator.Page(pageNum)
if err != nil {
    // Handle the error
    return
}
ctx.Set("paginator", page)
```

## Simplified Paginator Interface

The paginator package provides the following key interfaces:

```go
package pagination

// PageObject defines the structure for a paginated set of items.
type PageObject[T any] interface {
    Count() int        // Number of items on this page
    Results() []T      // The items on this page
    PageNum() int      // Current page number
    HasNext() bool     // Is there a next page?
    HasPrev() bool     // Is there a previous page?
    Next() int         // Next page number (-1 if none)
    Prev() int         // Previous page number (-1 if none)
    Paginator() Pagination[T]  // Reference to the paginator
}

// Pagination defines the structure of the paginator.
type Pagination[T any] interface {
    Count() (int, error)  // Total number of items
    Page(n int) (PageObject[T], error)  // Get a specific page
    NumPages() (int, error)  // Total number of pages
    PerPage() int  // Number of items per page
}
```

## HTML Rendering for Paginator

Here is a simple HTML template to render the paginated content:

```html
{{ $page := (.Get "paginator") }}

{{ range $item := $page.Results }}
    <div class="list-item">
        <div class="list-item__header">
            {{ $item.Label }}
        </div>
    </div>
{{ else }}
    <div class="list-item">
        <div class="list-item__body">
            <p class="list-empty-text">{{ T "No items found" }}</p>
        </div>
    </div>
{{ end }}

{{ $page.HTML "page" 5 .Request.URL.Query }}
```

## Explanation

- **GetObject**: Optionally modify or wrap each item before it's returned.
- **GetObjects**: Retrieve a specific range of items.
- **GetCount**: Get the total number of items.
- **Page**: Get a specific page of items based on the page number.
- **HTML Rendering**: Iterates over the results and displays them in a list. If no items are found, a message is displayed.

This simplified documentation provides a clear overview and a practical example of how to implement and use the paginator in your application.
