# Attributes

Attributes are used to define the properties of a model.

This is useful for providing form functionality and more.

Embedded struct support is easily implemented by your own code.

The `Attributes` interface allows for customizability of the model and it's formfields when auto-generating forms for it's fields, setting & retrieving values and more.

## Interfaces

To keep things uniform when working with attributes we have implemented a few interfaces.

These interfaces are already implemented in the framework, but for the sake of customizability you can implement them yourself.

### `Definer` interface

The `Definer` interface is used to define the properties of a model.

This interface has a single method, and should be defined on the model itself.

The interface definition:

```go
type Definer interface {
	FieldDefs() attrs.Definitions
}
```

### `Definitions` interface

### `Field` Interface

The field interface is used to define the properties of a field.

The interface itself also adheres to the following interfaces:

- `Labeler`
- `Helper`
- `Stringer`
- `Namer`

This allows each field to easily define labels, help texts, string representations and names for forms.

The full interface is defined as follows:

```go
type Field interface { // size=16 (0x10)
    Labeler
    Helper
    Stringer
    Namer
    Instance() Definer
    IsPrimary() bool
    AllowNull() bool
    AllowBlank() bool
    AllowEdit() bool
    GetValue() interface{}
    GetDefault() interface{}
    SetValue(v interface{}, force bool) error
    FormField() fields.Field
    Validate() error
}
```

As seen it is a quite extensive interface.

This is to allow for maximum customizability of the fields, while not sacrificing functionality in forms.

The methods are explained as follows:

- `Instance() Definer`  
  Returns the struct instance of the field.
- `IsPrimary() bool`  
  Returns whether the field is a primary identifier of this object.  
  For example, this can be used to easily identify the primary key field in a database.
- `AllowNull() bool`  
  Returns whether the field allows nil values.  
  If this is not true; a panic will be raised if the return object of `reflect.ValueOf` returns false when calling `IsValid` on that object.
- `AllowBlank() bool`  
  Returns whether the field allows blank (zero) values in forms.  
  If this is false, formfields generated by this (by default) will be required.  
  The framework does not always panic if a zero value is passed to a field that does not allow it, we only panic if the field's value is zero (reflect.IsZero) and not of types:
  - `bool`
  - `int/int8/int16/int32/int64`
  - `uint/uint8/uint16/uint32/uint64/uintptr`
  - `float32/float64`
  - `complex64/complex128`
- `AllowEdit() bool`  
  Mark this field as non-editable (editable by default).  
  This means a panic will be raised if the value of this field gets set.  
  Values still can be read at all times. Setting the value can also still occur, if the `force` parameter is set to true.
- `GetValue() interface{}`  
  Returns the value of the field.
- `GetDefault() interface{}`  
  Returns a default value for the field.  
  This can be overridden on the `Definer` struct by creating a method called `GetDefault<FieldName>` or optionally by populating the `Default` key in the `FieldConfig` struct.  
  When populating in the `FieldConfig` struct, a function that returns the default value for this is also allowed.  
  *warning*: Do not use pointer values as a default - this may cause unexpected behavior.
- `SetValue(v interface{}, force bool) error`  
  Sets the value of the field.  
  If `force` is set to true, the value will be set regardless of the `AllowEdit` setting.  
  If the value is not of the correct type, a panic will be raised.
- `FormField() fields.Field`
  Returns a form field for this field.  
  This is used to auto-generate forms for the model.
- `Validate() error`
  Validates the field.  
  This can be used to check if the field is valid.  
  If the field is not valid, an error should be returned.  
  If the field is valid, nil should be returned.

#### `Namer` interface

The `Namer` interface is used to define the name of a field.

This is useful for form generation and possibly even database columns, etc.

The interface is defined as follows:

```go
type Namer interface {
	Name() string
}
```

For a form, this is the name attribute of the field; any other implementation may vary.

#### `Stringer` interface

The `Stringer` interface is used to define the string representation of a field.

This interface varies from the `fmt.Stringer` interface; the method is called `ToString` instead of `String`.

It is mainly used in list representations; and should provide a human-readable string representation of the field.

The interface is defined as follows:

```go
type Stringer interface {
	ToString() string
}
```

#### `Labeler` interface

The `Labeler` interface is used to define the label of a field.

This should be the human-readable representation of the name of the field.

I.E. if your field's name is `firstName`, an appropriate label might be `First Name`.

Internally it is used in forms to generate labels for the fields or in lists to generate column headers.

The interface is defined as follows:

```go
type Labeler interface {
	Label() string
}
```

#### `Helper` interface

The `Helper` interface is used to define a help text for a field.

This is useful for providing additional information about the field, such as in forms.

The interface is defined as follows:

```go
type Helper interface {
	HelpText() string
}
```

#### `Scanner` interface

The `Scanner` interface is used to scan a value into a field.

This should be a method on the value of the field.

I.E. to scan a value into a `StringField`, the method should be defined on the `StringField` struct.

Example:

```go
type StringField struct {
    Value string
}

func (s *StringField) ScanAttribute(src any) error {
    if v, ok := src.(string); ok {
        s.Value = v
        return nil
    }
    return errors.New("Invalid type")
}

type MyStruct struct {
    MyField StringField
}
```

This allows for more complex logic when setting values.

The interface is defined as follows:

```go
type Scanner interface {
	ScanAttribute(src any) error
}
```

## Structs

### `FieldDef` struct

### `FieldConfig` struct

## Defining Model Attributes

### Embedding Structs

## Package- level functions

