// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package images

import (
	"context"
	"database/sql"
	"time"
)

const deleteImage = `-- name: DeleteImage :exec
DELETE FROM images
WHERE id = ?
`

func (q *queries) DeleteImage(ctx context.Context, id uint32) error {
	_, err := q.db.ExecContext(ctx, deleteImage, id)
	return err
}

const insertImage = `-- name: InsertImage :execlastid
INSERT INTO images (
    title,
    path,
    created_at,
    file_size,
    file_hash
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
)
`

func (q *queries) InsertImage(ctx context.Context, title string, path string, createdAt time.Time, fileSize sql.NullInt32, fileHash string) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertImage,
		title,
		path,
		createdAt,
		fileSize,
		fileHash,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const selectBasic = `-- name: SelectBasic :many
SELECT id, title, path, created_at, file_size, file_hash
FROM images
ORDER BY id
LIMIT ? OFFSET ?
`

func (q *queries) SelectBasic(ctx context.Context, limit int32, offset int32) ([]*Image, error) {
	rows, err := q.db.QueryContext(ctx, selectBasic, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Path,
			&i.CreatedAt,
			&i.FileSize,
			&i.FileHash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectByFileHash = `-- name: SelectByFileHash :one
SELECT id, title, path, created_at, file_size, file_hash
FROM images
WHERE file_hash = ?
`

func (q *queries) SelectByFileHash(ctx context.Context, fileHash string) (*Image, error) {
	row := q.db.QueryRowContext(ctx, selectByFileHash, fileHash)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Path,
		&i.CreatedAt,
		&i.FileSize,
		&i.FileHash,
	)
	return &i, err
}

const selectByID = `-- name: SelectByID :one
SELECT id, title, path, created_at, file_size, file_hash
FROM images
WHERE id = ?
`

func (q *queries) SelectByID(ctx context.Context, id uint32) (*Image, error) {
	row := q.db.QueryRowContext(ctx, selectByID, id)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Path,
		&i.CreatedAt,
		&i.FileSize,
		&i.FileHash,
	)
	return &i, err
}

const selectByPath = `-- name: SelectByPath :one
SELECT id, title, path, created_at, file_size, file_hash
FROM images
WHERE path = ?
`

func (q *queries) SelectByPath(ctx context.Context, path string) (*Image, error) {
	row := q.db.QueryRowContext(ctx, selectByPath, path)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Path,
		&i.CreatedAt,
		&i.FileSize,
		&i.FileHash,
	)
	return &i, err
}

const selectLargeToSmall = `-- name: SelectLargeToSmall :many
SELECT id, title, path, created_at, file_size, file_hash
FROM images
ORDER BY file_size DESC
LIMIT ? OFFSET ?
`

func (q *queries) SelectLargeToSmall(ctx context.Context, limit int32, offset int32) ([]*Image, error) {
	rows, err := q.db.QueryContext(ctx, selectLargeToSmall, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Path,
			&i.CreatedAt,
			&i.FileSize,
			&i.FileHash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNewestToOldest = `-- name: SelectNewestToOldest :many
SELECT id, title, path, created_at, file_size, file_hash
FROM images
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

func (q *queries) SelectNewestToOldest(ctx context.Context, limit int32, offset int32) ([]*Image, error) {
	rows, err := q.db.QueryContext(ctx, selectNewestToOldest, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Path,
			&i.CreatedAt,
			&i.FileSize,
			&i.FileHash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectOldestToNewest = `-- name: SelectOldestToNewest :many
SELECT id, title, path, created_at, file_size, file_hash
FROM images
ORDER BY created_at
LIMIT ? OFFSET ?
`

func (q *queries) SelectOldestToNewest(ctx context.Context, limit int32, offset int32) ([]*Image, error) {
	rows, err := q.db.QueryContext(ctx, selectOldestToNewest, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Path,
			&i.CreatedAt,
			&i.FileSize,
			&i.FileHash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSmallToLarge = `-- name: SelectSmallToLarge :many
SELECT id, title, path, created_at, file_size, file_hash
FROM images
ORDER BY file_size
LIMIT ? OFFSET ?
`

func (q *queries) SelectSmallToLarge(ctx context.Context, limit int32, offset int32) ([]*Image, error) {
	rows, err := q.db.QueryContext(ctx, selectSmallToLarge, limit, offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Path,
			&i.CreatedAt,
			&i.FileSize,
			&i.FileHash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateImage = `-- name: UpdateImage :exec
UPDATE images
SET
    title = ?,
    path = ?,
    created_at = ?,
    file_size = ?,
    file_hash = ?
WHERE id = ?
`

func (q *queries) UpdateImage(ctx context.Context, title string, path string, createdAt time.Time, fileSize sql.NullInt32, fileHash string, iD uint32) error {
	_, err := q.db.ExecContext(ctx, updateImage,
		title,
		path,
		createdAt,
		fileSize,
		fileHash,
		iD,
	)
	return err
}
